[
  {
    "question": "Что такое Data Science? ",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Наука о данных - это сочетание различных инструментов, алгоритмов и принципов машинного обучения, цель которых - выявить скрытые закономерности на основе необработанных данных.",
    "code_snippet": "",
    "key_terms": "[\"Машинное обучение\", \"Data Science\", ]"
  },
  {
    "question": "Перечислите различия между контролируемым и неконтролируемым обучением.",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Различия между обучением под наблюдением и без присмотра заключаются в следующем: Контролируемое обучение: входные данные помечены, используется тренировочный датасет, используется для предсказаний, Позволяет выполнять классификацию и регрессию; Неконтролируемое обучение: входные данные не помечены, используется входной набор данных, используется для анализа, Позволяет классифицировать, оценивать плотность и уменьшать размеры",
    "code_snippet": "",
    "key_terms": "[\"Контролируемое обучение\", \"Неконтролируемое обучение\"]"
  },
  {
    "question": "Что такое bias-variance trade-off",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Bias (смещение) — ошибка из-за упрощения модели (недообучение). Variance (разброс) — ошибка из-за сложности модели (переобучение). Оптимальная модель балансирует оба параметра. Примеры: 1) k-NN (низкий bias, высокий variance), 2) SVM (параметр C регулирует баланс",
    "code_snippet": "",
    "key_terms": "[\"bias\", \"variance\", \"underfitting\", \"overfitting\", \"k-NN\", \"SVM\"]"
  },
  {
    "question": "Что такое матрица ошибок?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Матрица 2x2 с показателями: TP, FP, TN, FN. Метрики: Accuracy = (TP+TN)/(P+N), Precision = TP/(TP+FP), Recall = TP/P, F1 = 2*(Precision*Recall)/(Precision+Recall)",
    "code_snippet": "",
    "key_terms": "[\"confusion matrix\", \"accuracy\", \"precision\", \"recall\", \"F1-score\", \"метрики классификации\"]"
  },
  {
    "question": "Что понимается под термином \"Нормальное распределение\"?",
    "category": "Statistics",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Данные могут распределяться различными способами — со смещением влево или вправо, либо быть хаотично разбросанными. Однако бывают случаи, когда данные распределены вокруг центрального значения без смещения влево или вправо, образуя нормальное распределение в виде колоколообразной кривой. Случайные величины распределены в форме симметричной колоколообразной кривой.\nСвойства нормального распределения:\nУнимодальность — одна мода\nСимметричность — левая и правая половины являются зеркальными отражениями\nКолоколообразная форма — максимальная высота (мода) на среднем значении\nСреднее, мода и медиана расположены в центре\nАсимптотичность ",
    "code_snippet": "",
    "key_terms": "[\"Нормальное распределение\", \"Колоколообразная кривая\", \"Симметричность\", \"Статистика\"]"
  },
  {
    "question": "Что такое корреляция и ковариация в статистике?",
    "category": "Statistics",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Ковариация и корреляция — это два математических понятия, широко используемых в статистике. Оба метода устанавливают взаимосвязь и измеряют зависимость между двумя случайными величинами. Хотя их математическая суть схожа, они различаются между собой. Корреляция:\nКорреляция считается лучшим методом для измерения и оценки количественной взаимосвязи между двумя переменными. Она показывает, насколько сильно связаны две переменные.\nКовариация:\nКовариация отражает совместную изменчивость двух величин и показывает степень, в которой две случайные переменные изменяются согласованно. Это статистический термин, описывающий систематическую взаимосвязь между парой случайных величин, где изменение одной переменной сопровождается соответствующим изменением другой.",
    "code_snippet": "",
    "key_terms": "[\"Корреляция\", \"Ковариация\", \"Статистика\", \"Зависимость переменных\"]"
  },
  {
    "question": "В чем разница между точечными оценками и доверительным интервалом?",
    "category": "Statistics",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Точечная оценка дает конкретное значение в качестве оценки параметра генеральной совокупности. Для получения точечных оценок используются методы моментов и метода максимального правдоподобия. Доверительный интервал предоставляет диапазон значений, который с высокой вероятностью содержит истинный параметр генеральной совокупности. Доверительный интервал обычно предпочтительнее, так как он показывает, насколько вероятно, что этот интервал содержит искомый параметр. Эта вероятность называется уровнем доверия (Confidence Level) и обозначается как 1 — α, где α — уровень значимости.",
    "code_snippet": "",
    "key_terms": "[\"Точечная оценка\", \"Доверительный интервал\", \"Уровень доверия\", \"Статистика\"] "
  },
  {
    "question": "Какова цель A/B-тестирования?",
    "category": "Statistics",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "A/B-тестирование - это метод проверки гипотез в рамках рандомизированного эксперимента с двумя вариантами (A и B). Цель A/B-тестирования - выявить изменения на веб-странице, которые позволяют максимизировать или увеличить целевой показатель. Этот метод является мощным инструментом для определения оптимальных онлайн-стратегий продвижения и маркетинга для бизнеса. С помощью A/B-тестирования можно проверять эффективность различных элементов: от текстов на сайте до рекламных писем и поисковой рекламы.",
    "code_snippet": "",
    "key_terms": "[\"A/B-тестирование\", \"Проверка гипотез\", \"Рандомизированный эксперимент\"]"
  },
  {
    "question": "Что такое p-значение (p-value)?",
    "category": "Statistics",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "При проведении статистической проверки гипотез p-значение помогает оценить силу ваших результатов. Это число между 0 и 1, которое показывает степень достоверности результатов. Проверяемое утверждение называется нулевой гипотезой. Низкое p-значение (≤ 0.05) свидетельствует против нулевой гипотезы, что позволяет нам её отвергнуть. Высокое p-значение (≥ 0.05) поддерживает нулевую гипотезу, и мы можем её принять. P-значение 0.05 означает, что гипотеза может быть как принята, так и отвергнута.\nДругими словами:\nВысокие p-значения: ваши данные вероятны при истинности нулевой гипотезы.\nНизкие p-значения: ваши данные маловероятны при истинности нулевой гипотезы. ",
    "code_snippet": "",
    "key_terms": "[\"p-значение\", \"Проверка гипотез\", \"Нулевая гипотеза\", \"Статистическая значимость\"]"
  },
  {
    "question": "Какова вероятность увидеть хотя бы одну падающую звезду за час, если в любом 15-минутном интервале эта вероятность составляет 20%?",
    "category": "Probability",
    "question_type": "case",
    "difficulty": "Medium",
    "reference_answer": "Дано: Вероятность увидеть ≥1 звезду за 15 минут: 20% (0.2)\nСледовательно, вероятность НЕ увидеть звезду за 15 минут: 1 - 0.2 = 0.8 Один час = 4 интервала по 15 минут\nВероятность НЕ увидеть звезду за час:\n0.8⁴ = 0.4096\nВероятность увидеть ≥1 звезду за час:\n1 - 0.4096 = 0.5904 (59.04%)\nОтвет: вероятность составляет примерно 59%.",
    "code_snippet": "",
    "key_terms": "[\"Вероятность\", \"Независимые события\", \"Геометрическое распределение\", \"Вероятность событий\"]"
  },
  {
    "question": "В банке 1000 монет: 999 честных и 1 с двумя орлами. Выбрали случайную монету и подбросили 10 раз, выпало 10 орлов. Какова вероятность, что при следующем подбрасывании этой монеты снова выпадет орёл?",
    "category": "Probability",
    "question_type": "case",
    "difficulty": "Hard",
    "reference_answer": "Решение с использованием теоремы Байеса: Априорные вероятности:\nP(честная) = 999/1000 = 0.999\nP(нечестная) = 1/1000 = 0.001\nВероятности получить 10 орлов:\nДля честной: (1/2)^10 = 1/1024 ≈ 0.000976\nДля нечестной: 1 (гарантировано)\nОбщая вероятность 10 орлов:\nP(10H) = (0.999 × 0.000976) + (0.001 × 1) ≈ 0.001976\nАпостериорные вероятности:\nP(честная|10H) = (0.999×0.000976)/0.001976 ≈ 0.4939\nP(нечестная|10H) = (0.001×1)/0.001976 ≈ 0.5061\nИтоговая вероятность следующего орла:\nP(11-й орёл) = (0.4939 × 0.5) + (0.5061 × 1) ≈ 0.753 (75.3%)\nОтвет: ≈ 75.3%",
    "code_snippet": "",
    "key_terms": "[\"Теорема Байеса\", \"Условная вероятность\", \"Апостериорная вероятность\"]"
  },
  {
    "question": "Что понимается под статистической мощностью (чувствительностью) и как её рассчитывают?",
    "category": "Statistics",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Чувствительность (Statistical Power/Sensitivity) - это метрика, используемая для оценки точности классификаторов (логистическая регрессия, SVM, Random Forest и др.). Она показывает долю правильно предсказанных положительных случаев среди всех фактически положительных случаев. Формула расчета:\nЧувствительность = Истинно положительные (True Positives) / Все положительные в реальных данных (Actual Positives)\nГде:\nИстинно положительные (TP) - случаи, которые модель правильно предсказала как положительные\nВсе положительные (P) - все реальные положительные случаи в данных\nВажно:\nЧувствительность также известна как \"полнота\" (recall)\nВ медицинских тестах называется \"true positive rate\"\nИдеальное значение - 1 (100%), худшее - 0",
    "code_snippet": "",
    "key_terms": "[\"Чувствительность\", \"Статистическая мощность\", \"True Positive Rate\", \"Метрики классификации\"] "
  },
  {
    "question": "В чем разница между переобучением (overfitting) и недообучением (underfitting)?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Переобучение (Overfitting) и недообучение (Underfitting) - две ключевые проблемы в машинном обучении: Переобучение:\nМодель слишком сложна и учитывает шум/случайные колебания в обучающих данных\nПроисходит при избыточном количестве параметров модели\nПоказывает отличные результаты на обучающих данных, но плохо обобщается на новые данные\nПример: дерево решений с чрезмерной глубиной\nНедообучение:\nМодель слишком проста и не может уловить основные закономерности данных\nПроисходит при недостаточной сложности модели\nПоказывает плохие результаты как на обучающих, так и на тестовых данных\nПример: линейная модель для нелинейных данных",
    "code_snippet": "",
    "key_terms": " [\"Переобучение\", \"Недообучение\", \"Машинное обучение\"]"
  },
  {
    "question": "Как бороться с переобучением и недообучением моделей?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Методы борьбы с переобучением и недообучением: Для переобучения (overfitting):\nРегуляризация (L1/L2)\nУпрощение архитектуры модели\nУвеличение обучающей выборки\nDropout (для нейронных сетей)\nРанняя остановка обучения\nУменьшение количества признаков\nДля недообучения (underfitting):\nУвеличение сложности модели\nДобавление новых признаков\nУменьшение регуляризации\nУвеличение времени обучения\nИспользование ансамблевых методов\nОбщие методы:\nКросс-валидация (k-fold)\nРазделение данных на обучающую/валидационную/тестовую выборки\nМониторинг метрик на валидационной выборке\nБалансировка bias-variance tradeoff",
    "code_snippet": "",
    "key_terms": " [\"Переобучение\", \"Недообучение\", \"Машинное обучение\", \"Регуляризация\"]"
  },
  {
    "question": "Что такое регуляризация и почему она важна?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Основные типы:\n1. L1 (Лассо) - способствует разреженности, обнуляя некоторые веса\n2. L2 (Ридж) - уменьшает величину всех весов\nПреимущества:\n- Уменьшает переобучение\n- Улучшает обобщающую способность\n- Помогает работать с мультиколлинеарностью\n- Делает модели более устойчивыми\nКогда использовать:\n- Когда модель показывает хорошие результаты на обучающих данных, но плохие на тестовых\n- При работе с большим количеством признаков\n- Когда нужно автоматически выбрать важные признаки (L1)",
    "code_snippet": "",
    "key_terms": "[\"Регуляризация\", \"L1 регуляризация\", \"L2 регуляризация\", \"Переобучение\", \"Лассо\", \"Ридж\"]"
  },
  {
    "question": "Что означает \"наивность\" в наивном байесовском классификаторе?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "1. Алгоритм использует теорему Байеса для вычисления вероятностей\n2. \"Наивное\" предположение: все признаки независимы друг от друга\n3. На практике это редко бывает верно, но алгоритм часто работает хорошо\n4. Такое упрощение значительно ускоряет вычисления\nПреимущества:\n- Простота реализации\n- Быстрая работа даже с большими наборами данных\n- Хорошо работает с категориальными признаками\n- Требует мало данных для обучения\nНесмотря на \"наивное\" предположение, алгоритм часто показывает хорошие результаты на практике.",
    "code_snippet": "",
    "key_terms": "[\"Наивный Байес\", \"Теорема Байеса\", \"Независимость признаков\", \"Классификация\"]"
  },
  {
    "question": "Объясните алгоритм SVM (метод опорных векторов)",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "1. **Геометрический подход**:\n- Данные отображаются в n-мерном пространстве (n - количество признаков)\n- Каждый признак соответствует своей координате\n2. **Разделение классов**:\n- Использует гиперплоскости для разделения классов\n- Выбирает гиперплоскость с максимальным зазором (margin)\n3. **Кernel trick**:\n- Линейные ядра (linear) - для линейно разделимых данных\n- Нелинейные ядра (RBF, polynomial) - для сложных случаев\n4. **Опорные векторы**:\n- Точки данных, ближайшие к гиперплоскости\n- Определяют положение разделяющей границы",
    "code_snippet": "",
    "key_terms": "[\"SVM\", \"Метод опорных векторов\", \"Гиперплоскость\", \"Kernel trick\"]"
  },
  {
    "question": "Что такое опорные векторы в SVM?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Основные характеристики:  \n1. Расположены ближе всего к гиперплоскости (на границах маржина)  \n2. Являются \"опорными\" для разделяющей границы  \n3. Только эти точки влияют на положение гиперплоскости  \nНа схеме:  \n- Тонкие линии: границы маржина (w*x+b=±1)  \n- Темные точки: опорные векторы  \n- Расстояние между линиями: величина маржина  \n**Свойства:**  \n- Чем меньше опорных векторов, тем более обобщающая модель  \n- Устойчивы к выбросам, не являющимся опорными векторами",
    "code_snippet": "",
    "key_terms": "[\"SVM\", \"Опорные векторы\", \"Маржин\", \"Гиперплоскость\"]"
  },
  {
    "question": "Объясните алгоритм дерева решений",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "**Основные компоненты:**  \n- **Декомпозиция данных**: разбивает набор данных на всё более мелкие подмножества  \n- **Ноды дерева**:  \n  - **Решение (decision nodes)**: точки ветвления по условиям  \n  - **Листья (leaf nodes)**: конечные предсказания  **Преимущества:**  \n- Работает с категориальными и числовыми данными  \n- Простота интерпретации  \n- Не требует масштабирования признаков  \n\n**Недостатки:**  \n- Склонность к переобучению  \n- Чувствительность к небольшим изменениям данных  \n**Ключевые параметры:**  \n- Глубина дерева (max_depth)  \n- Критерий разделения (gini/entropy)  \n- Минимальное число образцов в листе",
    "code_snippet": "",
    "key_terms": " [\"Дерево решений\", \"Классификация\", \"Регрессия\", \"Ноды\", \"Переобучение\"]"
  },
  {
    "question": "Что такое энтропия и информационный прирост в алгоритме дерева решений?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "**Энтропия:**  \n- Мера неопределенности/хаоса в данных  \n- Диапазон: от 0 (полная однородность) до 1 (максимальная неопределенность)  \n- Формула: Entropy = -Σ(p_i * log₂(p_i))  \n**Информационный прирост (Information Gain):**  \n- Показывает, насколько уменьшается энтропия после разделения по признаку  \n- Формула: IG = Entropy(родитель) - Σ [ (n_дочерний/n_родитель) * Entropy(дочерний) ]  \n- Алгоритм выбирает признаки с максимальным IG для разделения  Альтернатива - критерий Джини ",
    "code_snippet": "",
    "key_terms": "[\"Энтропия\", \"Информационный прирост\", \"ID3 алгоритм\", \"Дерево решений\"]"
  },
  {
    "question": "Что такое pruning (подрезка) в дереве решений?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "**Основные аспекты:**  \n1. **Цель**: предотвращение переобучения и упрощение модели  \n2. **Типы подрезки**:  \n   - Pre-pruning: остановка построения дерева до его полного роста  \n   - Post-pruning: удаление ветвей после построения полного дерева  \n**Как работает:**  \n- Удаляются подузлы, дающие незначительный вклад в классификацию  \n- Выполняется обратный процесс к разделению (splitting)  \n**Преимущества:**  \n- Уменьшает сложность модели  \n- Улучшает обобщающую способность  \n- Снижает риск переобучения  ",
    "code_snippet": "",
    "key_terms": "[\"Pruning\", \"Подрезка дерева\", \"Переобучение\", \"Дерево решений\"]"
  },
  {
    "question": "Как определить оптимальное количество кластеров в алгоритме кластеризации?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "1. **Метод локтя (Elbow Method)**:\n   - График зависимости Within-Cluster-Sum-of-Squares (WCSS) от числа кластеров\n   - Оптимальное K - точка изгиба (где уменьшение WCSS замедляется)\n2. **Иерархическая кластеризация**:\n   - Построение дендрограммы\n   - Анализ расстояний между кластерами\n3. **Другие методы**:\n   - Silhouette Score\n   - Gap Statistic\n   - Анализ устойчивости кластеров\n**Критерии выбора**:\n- Максимальная однородность внутри кластеров\n- Максимальная различимость между кластерами\n- Интерпретируемость результатов",
    "code_snippet": "",
    "key_terms": "[\"Кластеризация\", \"K-Means\", \"Метод локтя\", \"WCSS\", \"Дендрограмма\"]"
  },
  {
    "question": "Что такое ансамблевое обучение (Ensemble Learning)?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "**Основные принципы:**  \n- Объединение разнообразных моделей (\"слабых learners\")  \n- Улучшение стабильности и предсказательной силы  \n- Работает по принципу \"мудрости толпы\"  \n**Популярные методы:**  \n1. Bagging (например, Random Forest)  \n2. Boosting (например, XGBoost)  \n3. Stacking (многоуровневое объединение)  \n**Преимущества:**  \n- Повышение точности предсказаний  \n- Уменьшение переобучения  \n- Устойчивость к выбросам",
    "code_snippet": "",
    "key_terms": "[\"Ансамблевое обучение\", \"Bagging\", \"Boosting\", \"Random Forest\", \"XGBoost\"]"
  },
  {
    "question": "Опишите кратко основные типы ансамблевого обучения",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "1. **Bagging (Бэггинг)**  \n- Параллельное обучение однотипных моделей на подвыборках данных  \n- Уменьшает дисперсию ошибки (variance)  \n- Пример: Random Forest  \n- Использует bootstrap (выборку с возвращением)  \n2. **Boosting (Бустинг)**  \n- Последовательное обучение, где каждая модель исправляет ошибки предыдущей  \n- Уменьшает смещение (bias)  \n- Может приводить к переобучению  \n- Примеры: AdaBoost, Gradient Boosting  \n**Ключевые различия:**  \n|| Bagging | Boosting |  \n|:-|:-|:-|  \n|Тип|Параллельный|Последовательный|  \n|Ошибка|Уменьшает variance|Уменьшает bias|  \n|Чувствительность|Устойчив к шуму|Чувствителен к выбросам|",
    "code_snippet": "",
    "key_terms": "[\"Ансамблевое обучение\", \"Bagging\", \"Boosting\", \"Random Forest\", \"Gradient Boosting\"]"
  },
  {
    "question": "Что такое Random Forest (Случайный лес) и как он работает?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "**Принцип работы:**  \n1. Создается множество деревьев на:  \n   - Bootstrap-выборках (случайные подвыборки с повторениями)  \n   - Случайных подмножествах признаков для каждого разбиения  \n2. Результат определяется:  \n   - **Классификация**: голосование большинства  \n   - **Регрессия**: усреднение предсказаний  \n**Преимущества:**  \n- Устойчивость к переобучению  \n- Работа с пропущенными значениями  \n- Оценка важности признаков  \n**Гиперпараметры:**  \n- n_estimators: количество деревьев  \n- max_features: число признаков для разбиения  \n- max_depth: глубина деревьев",
    "code_snippet": "",
    "key_terms": "[\"Random Forest\", \"Ансамблевые методы\", \"Бэггинг\", \"Решающие деревья\"]"
  },
  {
    "question": "Как строится Random Forest?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "1. Для каждого дерева:  \n   - Создается bootstrap-выборка  \n   - На каждом разбиении рассматривается случайное подмножество признаков (m из p)  \n2. Правила выбора m:  \n   - Классификация: m ≈ √p  \n   - Регрессия: m ≈ p/3  \n3. Объединение результатов:  \n   - Агрегация предсказаний всех деревьев  \n**Особенности:**  \n- Каждое дерево строится независимо  \n- Разнообразие достигается за счет:  \n  - Случайности выборок  \n  - Ограничения признаков для разбиений",
    "code_snippet": "",
    "key_terms": "[\"Bootstrap\", \"Случайные подмножества\", \"Ансамбль деревьев\"]"
  },
  {
    "question": "Почему точность 96% в задаче детекции рака может быть недостаточной и как улучшить модель?",
    "category": "Data Science",
    "question_type": "case",
    "difficulty": "Hard",
    "reference_answer": "1. **Ошибки в 4% могут быть критичны** - при диагностике рака ложные отрицания (False Negatives) опаснее ложных срабатываний  \n2. **Accuracy парадокс** - модель может достигать высокой точности, просто всегда предсказывая большинство класс  \n\n**Методы улучшения:**  \n1. **Правильные метрики:**  \n   - Чувствительность (Recall/Sensitivity) - минимизация ложноотрицательных случаев  \n   - F1-score - баланс между точностью и полнотой  \n   - ROC-AUC - оценка качества разделения классов  \n2. **Техники работы с данными:**  \n   - Взвешивание классов (class_weight)  \n   - Оверсэмплинг миноритарного класса (SMOTE)  \n   - Андерсэмплинг мажоритарного класса  \n3. **Оптимизация модели:**  \n   - Настройка порога классификации  \n   - Использование алгоритмов, устойчивых к дисбалансу (например, деревья решений)  ",
    "code_snippet": "",
    "key_terms": "[\"Дисбаланс классов\", \"Чувствительность\", \"F1-score\", \"SMOTE\", \"ROC-AUC\"]"
  },
  {
    "question": "Как проанализировать датасет и построить модель для предсказания целевой переменной? Опишите шаги",
    "category": "Data Science",
    "question_type": "case",
    "difficulty": "Medium",
    "reference_answer": "1. **Разведка данных (EDA)**\n   - Анализ распределений и корреляций\n   - Поиск пропусков и выбросов\n2. **Предобработка**\n   - Обработка пропусков (заполнение/удаление)\n   - Кодирование категориальных фичей\n   - Нормализация числовых признаков\n3. **Построение модели**\n   - Выбор алгоритма (классификация/регрессия)\n   - Разделение на train/test\n   - Обучение базовой модели\n4. **Оптимизация**\n   - Настройка гиперпараметров\n   - Проверка на кросс-валидации\n   - Отбор важных признаков\n5. **Интерпретация**\n   - Анализ метрик качества\n   - Оценка важности признаков\n   - Документирование результатов\n**Рекомендации:**\n- Начинать с простых моделей (логистическая регрессия)\n- Использовать pipeline для воспроизводимости\n- Выбирать метрики согласно бизнес-целям",
    "code_snippet": "",
    "key_terms": "[\"EDA\", \"Предобработка\", \"Кросс-валидация\", \"Гиперпараметры\", \"Feature Importance\"]"
  },
  {
    "question": "Как вы можете сгенерировать случайное число от 1 до 7, используя только кубик?",
    "category": "Data Science",
    "question_type": "case",
    "difficulty": "Medium",
    "reference_answer": "У любого кубика шесть сторон от 1 до 6. Невозможно получить семь одинаковых результатов при одном броске кубика. Если мы бросим кубик дважды и рассмотрим случай двух бросков, то получим 36 различных результатов. • Чтобы получить наши 7 равных исходов, мы должны сократить эти 36 до числа, кратного 7. Таким образом, мы можем рассмотреть только 35 исходов и исключить остальные. • Простым сценарием может быть исключение комбинации (6,6), т.е. повторный бросок кубика, если 6 выпадет дважды. • Все оставшиеся комбинации от (1,1) до (6,5) можно разделить на 7 частей по 5 в каждой. Таким образом, все все семь вариантов исхода одинаково вероятны.",
    "code_snippet": "",
    "key_terms": "[\"Теория вероятностей\", \"Моделирование случайных событий\", \"Равномерное распределение\", \"Генерация случайных чисел\"]"
  },
  {
    "question": "Некая супружеская пара сообщает вам, что у них двое детей, по крайней мере, одна из которых девочка. Какова вероятность того, что у них две девочки?",
    "category": "Data Science",
    "question_type": "case",
    "difficulty": "Medium",
    "reference_answer": "В случае двух детей существует 4 равновероятных варианта BB, \nBG, GB и GGG;  \nгде B = Мальчик и G = Девочка, а первая буква обозначает первого ребенка.  \nИз вопроса мы можем исключить первый вариант BB. Таким образом, из оставшихся 3-х вариантов BG, GB \n и BB мы должны найти вероятность случая с двумя девушками.  \nТаким образом, P (При наличии двух девушек и одной девушки) = 1/3",
    "code_snippet": "",
    "key_terms": "[\"Вероятность\",\"Условная вероятность\",\"Равновероятные варианты\",\"Комбинаторика\", \"Теория вероятностей\"]"
  },
  {
    "question": "Что такое Закон больших чисел?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Это теорема, которая описывает результат выполнения одного и того же эксперимента большое количество раз. Эта\nтеорема лежит в основе частотного подхода. Она гласит, что выборочные значения, дисперсия выборки\nи стандартное отклонение выборки сходятся к тому, что они пытаются оценить.",
    "code_snippet": "",
    "key_terms": "[\"Закон больших чисел\", \"Теорема\", \"Частотный подход\",\"Выборочные значения\", \"Дисперсия\",\"Стандартное отклонение\",\"Сходимость\", \"Статистика\", \"Теория вероятностей\"]"
  },
  {
    "question": "Что такое TF-IDF векторизация",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "TF–IDF - это сокращение от термина \"частота, обратная частоте документа\", это числовой статистический\nпоказатель, который отражает важность слова для документа в коллекции или корпусе. Он часто используется в качестве весового коэффициента\nпри поиске информации и анализе текста.  \nЗначение TF–IDF увеличивается пропорционально количеству встречаний слова в документе, но\nкомпенсируется частотой этого слова в тексте, что помогает учесть тот факт, что некоторые слова\nв целом встречаются чаще.",
    "code_snippet": "",
    "key_terms": "[\"TF-IDF\",\"Векторизация текста\", \"Частота термина\", \"Обратная частота документа\", \"Весовой коэффициент\",\"Информационный поиск\",\"Анализ текста\", \"Машинное обучение\", \"Преобразование текста\",\"Scikit-learn\"]"
  },
  {
    "question": "Что такое корутина в Python?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Это асинхронные функции, которые объявляются через async.\nВ момент ожидания, например, ответа от сервера, корутина приостанавливает свою работу, чтобы могла запуститься следующая. А когда ответ получен, продолжает свою работу.",
    "code_snippet": "",
    "key_terms": "[\n  \"Корутины\",\n  \"Асинхронные функции\",\n  \"async def\",\n  \"await\",\n  \"Асинхронное программирование\",\n  \"Сопрограммы\",\n  \"Приостановка выполнения\",\n  \"Возобновление выполнения\",\n  \"Модуль asyncio\",\n  \"Кооперативная многозадачность\"\n]"
  },
  {
    "question": "Как аргументы передаются в функции: по значению или по ссылке?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "В Python аргументы передаются по ссылке на объект. Это означает, что когда вы передаете объект в качестве аргумента функции, функция получает ссылку на этот объект, а не его копию. Если вы модифицируете объект внутри функции, эти изменения будут отражены и вне функции, так как обе переменные (внутри и вне функции) ссылаются на один и тот же объект в памяти. \nОднако, если внутри функции вы присваиваете новое значение аргументу, это не изменит значение переменной, которую вы использовали при вызове функции, потому что эта переменная по-прежнему ссылается на тот же объект в памяти.",
    "code_snippet": "",
    "key_terms": "[\n  \"Передача аргументов\",\n  \"Объекты в Python\",\n  \"Изменяемые и неизменяемые типы\",\n  \"Ссылки на объекты\",\n  \"Модификация объектов\",\n  \"Функции в Python\",\n  \"Поведение аргументов\",\n  \"Память и ссылки\"\n]"
  },
  {
    "question": "Как Python ищет модули при импорте?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "При импортировании модулей интерпретатор Python ищет их в директориях и архивах, список которых доступен как для чтения, так и для модификации в виде переменной path встроенного модуля sys. \nПо умолчанию sys.path состоит из директории с запускаемым скриптом, содержимого переменной окружения PYTHONPATH и стандартного расположения модулей, специфичного для конкретной платформы и интерпретатора.",
    "code_snippet": "",
    "key_terms": "[\n  \"Импорт модулей\",\n  \"Поиск модулей\",\n  \"sys.path\",\n  \"PYTHONPATH\",\n  \"Текущий каталог\",\n  \"Пути поиска модулей\",\n  \"Загрузка модулей\",\n  \"Кэширование модулей\",\n  \"Область видимости\",\n  \"Модуль Python\",\n  \"Пакеты и модули\",\n  \"Виртуальное окружение\"\n]"
  },
  {
    "question": "Что такое дескриптор?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Дескриптор в Python - это объект, который определяет, как атрибуты класса должны быть доступны, устанавливаемы и удалены. \nДескрипторы предоставляют программистам более мощный способ управления атрибутами объектов, и они широко используются в различных библиотеках и фреймворках Python.\nДескрипторы предоставляют три метода: get, set, и delete. Метод get вызывается при обращении к атрибуту, set - при попытке установить его значение, а delete - при удалении атрибута.",
    "code_snippet": "",
    "key_terms": "[\n  \"Дескриптор\",\n  \"Python\",\n  \"Протокол дескриптора\",\n  \"__get__\",\n  \"__set__\",\n  \"__delete__\",\n  \"Управление атрибутами\",\n  \"Кастомизация поведения\",\n  \"Валидация данных\",\n  \"Методы дескриптора\",\n  \"Атрибуты класса\",\n  \"Механизм доступа к атрибутам\",\n  \"Объектно-ориентированное программирование\"\n]"
  },
  {
    "question": "Опишите процесс компиляции в python.",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Python — это интерпретируемый язык, а это значит, что он не требует компиляции, как C или C++. Вместо этого интерпретатор Python читает и выполняет исходный код напрямую. \nОднако Python использует форму компиляции, называемую компиляцией байт-кода.\nКогда сценарий Python запускается в первый раз, интерпретатор компилирует его в байтовый код, представляющий собой низкоуровневое представление исходного кода. Затем этот байт-код выполняется виртуальной машиной Python (PVM), которая представляет собой интерпретатор, который считывает байт-код и выполняет его.\nБайт-код хранится в каталоге pycache с расширением .pyc. Python проверяет, есть ли у файла .py уже соответствующий файл .pyc, и, если файл .pyc старше файла .py, он компилирует файл .py в новый файл .pyc.\nТаким образом, процесс «компиляции» в Python включает интерпретатор, который компилирует исходный код в байтовый код, который затем выполняется PVM. \nОднако этот процесс происходит автоматически и за кулисами, без необходимости пользователю явно вызывать отдельный шаг компиляции.",
    "code_snippet": "",
    "key_terms": "[\n  \"Компиляция в Python\",\n  \"Интерпретируемый язык\",\n  \"Байт-код\",\n  \"Виртуальная машина Python (PVM)\",\n  \"Файл .pyc\",\n  \"__pycache__\",\n  \"Автоматическая компиляция\",\n  \"Интерпретатор Python\",\n  \"Преобразование исходного кода\",\n  \"Выполнение байт-кода\",\n  \"Оптимизация запуска\",\n  \"Преобразование AST\",\n  \"Граф потока управления\",\n  \"Модуль compile\",\n  \"py_compile\"\n]"
  },
  {
    "question": "Что такое связка try-catch-finally?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "try — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке. catch — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения. finally — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока catch. Управление передаётся в блок finally в любом случае, было выброшено исключение или нет.\nОбщий вид конструкции для обработки исключительной ситуации выглядит следующим образом:\n\ntry { \n    //код, который потенциально может привести к исключительной ситуации \n} \ncatch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  \n    //код обработки исключительной ситуации\n} \nfinally {\n    //необязательный блок, код которого выполняется в любом случае\n}",
    "code_snippet": "",
    "key_terms": "[\n  \"try-catch-finally\",\n  \"Обработка исключений\",\n  \"Исключения\",\n  \"Блок try\",\n  \"Блок catch\",\n  \"Блок finally\",\n  \"Перехват ошибок\",\n  \"Обработка ошибок\",\n  \"Управление потоком выполнения\",\n  \"Java\",\n  \"Конструкция обработки исключений\",\n  \"Обязательный и необязательный блок\",\n  \"Исключительные ситуации\",\n  \"Код очистки\",\n  \"Безопасное выполнение кода\"\n]"
  },
  {
    "question": "Что такое enumerate()?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "enumerate() - это встроенная функция, которая используется для перебора элемента последовательност и получения пары (индекс, элемент) для каждого элемента",
    "code_snippet": "",
    "key_terms": "[\n  \"enumerate\",\n  \"Встроенная функция\",\n  \"Итерируемый объект\",\n  \"Индекс элемента\",\n  \"Пара (индекс, элемент)\",\n  \"Объект-итератор\",\n  \"Цикл for\",\n  \"Начальный индекс\",\n  \"Перебор коллекций\",\n  \"Python\",\n  \"Генератор кортежей\",\n  \"Упаковка и распаковка\",\n  \"range\",\n  \"Итерация с индексом\",\n  \"Оптимизация кода\"\n]"
  },
  {
    "question": "Процессы и потоки в Python",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "Одной из ключевых особенностей языка программирования Python является поддержка параллельного и конкурентного программирования с использованием модулей multiprocessing и threading соответственно. \nПроцесс — это независимая единица выполнения в операционной системе. Каждый процесс имеет собственный набор ресурсов и изолирован от других процессов.\nПоток — это подмножество процесса. В одном процессе может быть один или несколько потоков, которые разделяют ресурсы этого процесса, такие как память и файловые дескрипторы.\nМодуль multiprocessing в Python позволяет создавать процессы и управлять ими. Каждый такой процесс выполняется в своем собственном пространстве памяти и имеет свой собственный интерпретатор Python. Это означает, что каждый процесс может выполняться независимо и не зависит от выполнения других процессов.\nОднако, такая изоляция процессов идет в ущерб скорости их создания и коммуникации между ними.\nМодуль threading, с другой стороны, позволяет создавать потоки в рамках одного процесса. Потоки разделяют общую память процесса, поэтому создание и коммуникация между потоками происходит быстрее, чем между процессами.\nОднако, в Python есть такая особенность как Global Interpreter Lock (GIL), которая означает, что в любой момент времени только один поток может исполнять байт-код Python. Это делает модуль threading менее эффективным для задач, требующих большого количества вычислений.",
    "code_snippet": "",
    "key_terms": "[\n  \"Процессы\",\n  \"Потоки\",\n  \"Python\",\n  \"multiprocessing\",\n  \"threading\",\n  \"Параллельное программирование\",\n  \"Конкурентное программирование\",\n  \"Global Interpreter Lock (GIL)\",\n  \"Изоляция процессов\",\n  \"Общая память\",\n  \"Вычислительно интенсивные задачи\",\n  \"Операции ввода-вывода\",\n  \"Синхронизация потоков\",\n  \"Многопроцессность\",\n  \"Многопоточность\"\n]"
  },
  {
    "question": "Почему пустой список нельзя использовать как аргумент по умолчанию?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Значения по умолчанию для аргументов функции вычисляются только один раз, когда функция определяется, а не каждый раз, когда она вызывается. \nТаким образом, если вы попытаетесь использовать изменяемый тип данных (например, список) как аргумент по умолчанию для функции, то каждый вызов функции, который изменяет это значение, также изменит значение по умолчанию для всех последующих вызовов функции. \nЭто может привести к неожиданным поведениям.",
    "code_snippet": "",
    "key_terms": "[\n  \"Аргументы по умолчанию\",\n  \"Изменяемые объекты\",\n  \"Пустой список\",\n  \"Функции Python\",\n  \"Поведение по умолчанию\",\n  \"Мутация объектов\",\n  \"Опасности использования изменяемых типов\",\n  \"Область видимости переменных\",\n  \"Инициализация аргументов\",\n  \"Неожиданное поведение\",\n  \"Рекомендации по программированию\",\n  \"Immutable vs Mutable\",\n  \"Функциональное программирование\",\n  \"Память и состояние\",\n  \"Лучшие практики\"\n]"
  },
  {
    "question": "Разница между __new__ и __init__?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Оба метода связаны с процессом создания объектов, но выполняют разные задачи и вызываются в разные моменты жизненного цикла объекта. \n__new__ метод, который вызывается для создания нового экземпляра класса. \nОн отвечает за выделение памяти создание объекта до его инициализации (инициализация методом __init__). \nВозвращает новый экземпляр класса. \n__init__ является методом экземпляра класса, который вызывается после создания объекта (после метода __new__) и используется для инициализации атрибутов объекта. \nОн ничего не возвращает, а просто инициализирует значения атрибутов объекта.",
    "code_snippet": "",
    "key_terms": "[\n  \"__new__\",\n  \"__init__\",\n  \"Создание объекта\",\n  \"Инициализация объекта\",\n  \"Жизненный цикл объекта\",\n  \"Статический метод\",\n  \"Метод экземпляра\",\n  \"Выделение памяти\",\n  \"Возвращение экземпляра\",\n  \"Переопределение методов\",\n  \"Python\",\n  \"Объектно-ориентированное программирование\",\n  \"Вызов методов\",\n  \"Immutable объекты\",\n  \"Пример использования\"\n]"
  },
  {
    "question": "Что такое рекурсия в Python и как она работает?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Рекурсия - это техника, при которой функция вызывает саму себя для решения задач. Когда функция вызывает саму себя, она создает новый экземпляр функции, \nкоторый работает независимо от оригинального вызова, и таким образом, решает более простую версию задачи.\nПроцесс выполняется до достижения терминального условия, которое указывает на завершение рекурсии.",
    "code_snippet": "",
    "key_terms": "[\n  \"Рекурсия\",\n  \"Рекурсивная функция\",\n  \"Базовый случай\",\n  \"Рекурсивный случай\",\n  \"Вызов функции самой себя\",\n  \"Терминальное условие\",\n  \"Факториал\",\n  \"Python\",\n  \"Стек вызовов\",\n  \"Глубина рекурсии\",\n  \"RecursionError\",\n  \"Обход графа\",\n  \"Динамические структуры данных\",\n  \"Подзадачи\",\n  \"Эффективность рекурсии\"\n]"
  },
  {
    "question": "Напишите однострочник, который будет подсчитывать количество заглавных букв в файле.",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "num_upp = sum(1 for line in open(\"filename.txt\") for character in line if character.isupper())",
    "code_snippet": "num_upp = sum(1 for line in open(\"filename.txt\") for character in line if character.isupper())",
    "key_terms": "[\n  \"Однострочник\",\n  \"Подсчет заглавных букв\",\n  \"Файл\",\n  \"Python\",\n  \"sum\",\n  \"Генераторное выражение\",\n  \"Открытие файла\",\n  \"Итерация по строкам\",\n  \"Метод isupper()\",\n  \"Обработка текста\",\n  \"Функции высшего порядка\",\n  \"Эффективность\",\n  \"Чтение файлов\",\n  \"Обработка символов\",\n  \"Кодировка\"\n]"
  },
  {
    "question": "Что такое @classmethod, @staticmethod, @property?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "@classmethod, @staticmethod, and @property - это декораторы методов класса в языке Python.\n@classmethod декоратор используется для создания методов, которые будут работать с классом в целом, а не с отдельным экземпляром. В качестве первого параметра этот метод принимает класс, а не экземпляр объекта, и часто используется для создания фабричных методов и методов, которые работают с класс-уровнем методов.\n@staticmethod декоратор работает подобно @classmethod, но он не получает доступ к классу в качестве первого параметра.\n@property декоратор используется для создания свойств объекта, которые можно получить и задать, но выглядят как обычные атрибуты объекта. Это позволяет управлять доступом к атрибутам объекта, установив условиями доступа и возможностью заложить дополнительную логику при чтении, установке или удалении атрибута.",
    "code_snippet": "",
    "key_terms": "[\n  \"@classmethod\",\n  \"@staticmethod\",\n  \"@property\",\n  \"Декораторы методов\",\n  \"Методы класса\",\n  \"Методы экземпляра\",\n  \"Фабричные методы\",\n  \"Альтернативные конструкторы\",\n  \"Управление атрибутами\",\n  \"Логика доступа к атрибутам\",\n  \"Python\",\n  \"cls\",\n  \"self\",\n  \"Вызов методов класса\",\n  \"Вызов статических методов\"\n]"
  },
  {
    "question": "В чём разница между пакетами и модулями?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Модуль - это файл, содержащий код Python, который может быть повторно использован в других программах.\nПакет - это директория, содержащая один или несколько модулей (или пакетов внутри пакетов), а также специальный файл init.py, который выполняется при импорте пакета. Он может содержать код, который инициализирует переменные, функции и классы, и становится доступным для использования внутри модулей, находящихся внутри этого пакета.\n\nТаким образом, основная разница между модулем и пакетом заключается в том, что модуль - это файл с кодом, который можно использовать повторно, а пакет - это директория, которая может содержать один или несколько модулей. Код, находящийся в файле init.py, может инициализировать переменные, функции и классы, что обеспечивает общую функциональность для всех модулей, находящихся внутри пакета.",
    "code_snippet": "",
    "key_terms": "[\n  \"Модуль\",\n  \"Пакет\",\n  \"Python\",\n  \"Файл .py\",\n  \"Директория\",\n  \"__init__.py\",\n  \"Повторное использование кода\",\n  \"Импорт модулей\",\n  \"Импорт пакетов\",\n  \"Иерархия модулей\",\n  \"Вложенные пакеты\",\n  \"Инициализация пакета\",\n  \"Организация кода\",\n  \"Пространства имён\",\n  \"Структура проекта\"\n]"
  },
  {
    "question": "Каким будет результат следующего выражения? \nlen(\" \".join(list(map(str, [[0], [1]]))))",
    "category": "Python",
    "question_type": "case",
    "difficulty": "Easy",
    "reference_answer": "Вот разбивка того, как был получен этот результат:\n- Внутреннее выражение map(str, [[0], [1]]) преобразует целые значения 0 и 1 в строки, в результате чего получается [\"0\", \"1\"].\n- Затем функция списка преобразует этот итератор в список.\n- Метод соединения соединяет элементы списка пробелом, в результате чего получается строка «0 1».\n- Наконец, функция len возвращает длину этой строки, которая равна 3.",
    "code_snippet": "",
    "key_terms": "[\n  \"len\",\n  \"join\",\n  \"map\",\n  \"str\",\n  \"list\",\n  \"Преобразование типов\",\n  \"Итераторы\",\n  \"Функции высшего порядка\",\n  \"Строковые методы\",\n  \"Обработка списков\",\n  \"Python\",\n  \"Длина строки\",\n  \"Конкатенация строк\",\n  \"Пробел как разделитель\",\n  \"Вложенные списки\"\n]"
  },
  {
    "question": "Что такое virtualenv?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Virtualenv - это инструмент для создания изолированных Python-окружений, где каждое из окружений может иметь свои собственные установленные пакеты и зависимости. Это позволяет вам использовать различные версии Python и библиотек в разных проектах, не взаимодействуя друг с другом, и также создавать \"чистые\" окружения, где не установлены стандартные библиотеки, чтобы избежать конфликтов зависимостей. Вы можете активировать виртуальное окружение с помощью команды в командной строке, и когда оно активно, ваше приложение будет использовать только пакеты, установленные в данный момент в этом окружении.",
    "code_snippet": "",
    "key_terms": "[\n  \"virtualenv\",\n  \"Виртуальное окружение\",\n  \"Изоляция зависимостей\",\n  \"Python\",\n  \"Управление пакетами\",\n  \"Изолированные среды\",\n  \"Версии Python\",\n  \"Активация виртуального окружения\",\n  \"pip\",\n  \"venv\",\n  \"Конфликты зависимостей\",\n  \"Проекты Python\",\n  \"Директория виртуального окружения\",\n  \"Деактивация окружения\",\n  \"Установка пакетов\"\n]"
  },
  {
    "question": "Возвращают ли функции что-то, даже если нет оператора return?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Да, в Python функции всегда возвращают какое-то значение, даже если внутри них нет оператора return или оператор return без значения. Если оператор return отсутствует, то функция вернет значение None, что может быть использовано в качестве дефолтного значением в тех случаях, когда функция должна вернуть значение, но не имеет конкретных результатов для возврата.",
    "code_snippet": "",
    "key_terms": "[\n  \"Функции в Python\",\n  \"Возврат значения\",\n  \"Оператор return\",\n  \"Возврат None\",\n  \"Отсутствие return\",\n  \"Значение по умолчанию\",\n  \"Завершение функции\",\n  \"NoneType\",\n  \"Использование return\",\n  \"Поведение функций без return\",\n  \"Python\",\n  \"Типы возвращаемых значений\",\n  \"Пример функции\",\n  \"Обработка результата функции\",\n  \"Стиль программирования\"\n]"
  },
  {
    "question": "Можно ли создать декоратор из класса?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Да. Декораторы, определенные как классы, предоставляют другой способ создания декораторов с использованием ООП подхода. \nДля того, чтобы класс мог быть использован в качестве декоратора, он должен определить методы __init__()  и __call__() \n__init__() - инициализирует объект класса и позволяет передавать аргументы декоратору (если необходимо)\n__call__() - делает объект класса вызываемым. Этот метод будет вызываться, когда декорируемая функция будет вызываться.",
    "code_snippet": "",
    "key_terms": "[\n  \"Декоратор\",\n  \"Класс-декоратор\",\n  \"__init__\",\n  \"__call__\",\n  \"Объектно-ориентированное программирование\",\n  \"Вызов объекта\",\n  \"Python\",\n  \"Функции высшего порядка\",\n  \"Передача аргументов\",\n  \"Декорирование функций\",\n  \"Методы класса\",\n  \"Поведение объектов\",\n  \"ООП подход\",\n  \"Функциональное программирование\",\n  \"Использование классов как декораторов\"\n]"
  },
  {
    "question": "Что такое GIL?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "Python Global Interpreter Lock (глобальная блокировка интерпретатора), или GIL, простыми словами, представляет собой мьютекс (или блокировку), который позволяет только одному потоку контролировать интерпретатор Python.\nЭто означает, что в любой момент времени в состоянии выполнения может находиться только один поток. \nВлияние GIL не заметно для разработчиков, выполняющих однопоточные программы, но оно может стать узким местом в производительности процессорного и многопоточного кода.\nПоскольку GIL позволяет одновременно выполнять только один поток даже в многопоточной архитектуре с более чем одним ядром процессора, он приобрел репутацию «печально известной» особенности Python.",
    "code_snippet": "",
    "key_terms": "[\n  \"Global Interpreter Lock\",\n  \"GIL\",\n  \"Мьютекс\",\n  \"Потокобезопасность\",\n  \"Python\",\n  \"Многопоточность\",\n  \"Блокировка интерпретатора\",\n  \"Ограничение параллелизма\",\n  \"Однопоточные программы\",\n  \"Многопроцессорные системы\",\n  \"Конкуренция потоков\",\n  \"Выполнение байт-кода\",\n  \"CPython\",\n  \"Поток выполнения\",\n  \"Проблемы производительности\"\n]"
  },
  {
    "question": "Объясните isinstance()",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Функция isinstance() используется для проверки принадлежности объекта к определенному типу данных. Она принимает два аргумента: объект, который нужно проверить, и тип данных, к которому нужно проверить его принадлежность. Возвращает True, если объект принадлежит указанному типу, и False в противном случае.",
    "code_snippet": "",
    "key_terms": "[\n  \"isinstance\",\n  \"проверка типа\",\n  \"принадлежность объекта\",\n  \"тип данных\",\n  \"класс\",\n  \"экземпляр класса\",\n  \"подкласс\",\n  \"кортеж типов\",\n  \"возвращает True или False\",\n  \"Python\",\n  \"функция isinstance()\",\n  \"параметры: object, classinfo\",\n  \"проверка наследования\",\n  \"обработка нескольких типов\",\n  \"исключение TypeError\",\n  \"динамическая типизация\",\n  \"безопасность типов\",\n  \"проверка перед операциями\",\n  \"отличие от type()\"\n]"
  },
  {
    "question": "Как работают any() и all()?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Any возвращает true, если хоть один элемент в последовательности соответствует условию, то есть является true.\nAll возвращает true только в том случае, если условию соответствуют все элементы в последовательности.",
    "code_snippet": "",
    "key_terms": "[\n  \"any\",\n  \"all\",\n  \"функции Python\",\n  \"итерация\",\n  \"истинность элементов\",\n  \"логическое И\",\n  \"логическое ИЛИ\",\n  \"итерируемые объекты\",\n  \"возвращают True или False\",\n  \"короткое замыкание\",\n  \"проверка условий\",\n  \"пустая последовательность\",\n  \"эффективность\",\n  \"генераторы\",\n  \"списки\",\n  \"булевы значения\",\n  \"условные выражения\",\n  \"логические операции\",\n  \"проверка элементов коллекции\"\n]"
  },
  {
    "question": "Что такое область видимости переменных?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Область видимости переменных - это часть программы, где определенная переменная имеет смысл и доступна для использования. \nКаждая переменная имеет свою область видимости, что означает, что она может быть использована только в определенной части кода, а не везде в программе.\nГлобальная область видимости: переменные, которые определены вне всех функций или классов, имеют глобальную область видимости. \nЭто означает, что такие переменные доступны в любой части программы. Для изменения их значений внутри функций или классов необходимо использовать ключевое слово global. \nЛокальная область видимости: переменные, определенные внутри функций и классов, имеют локальную область видимости. \nЭто означает, что такие переменные существуют только внутри тела функции или класса и не видны за его пределами.",
    "code_snippet": "",
    "key_terms": "[\n  \"область видимости\",\n  \"переменные\",\n  \"глобальная область видимости\",\n  \"локальная область видимости\",\n  \"доступность переменных\",\n  \"переменные вне функций\",\n  \"переменные внутри функций\",\n  \"ключевое слово global\",\n  \"использование переменных\",\n  \"Python\",\n  \"видимость переменных\",\n  \"функции\",\n  \"классы\",\n  \"область действия переменных\",\n  \"жизненный цикл переменных\",\n  \"ограничение доступа\",\n  \"переменные и пространство имён\",\n  \"scope\",\n  \"LEGB правило\",\n  \"локальные и глобальные переменные\"\n]"
  },
  {
    "question": "Как проверить, что один кортеж содержит все элементы другого кортежа?",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Easy",
    "reference_answer": "Для проверки того, содержит ли один кортеж все элементы другого кортежа в Python, можно воспользоваться встроенной функцией all(), передав ей выражение генератора списков, которое проверяет наличие каждого элемента из второго кортежа в первом кортеже. \nНапример,\nfirst_tuple = (1, 2, 3, 4, 5)\nsecond_tuple = (2, 4, 5)\ncontains_all = all(elem in first_tuple for elem in second_tuple)\nOutput: True",
    "code_snippet": "first_tuple = (1, 2, 3, 4, 5)",
    "key_terms": "[\n  \"кортеж\",\n  \"tuple\",\n  \"проверка содержимого\",\n  \"вложенный кортеж\",\n  \"all()\",\n  \"генераторное выражение\",\n  \"проверка элементов\",\n  \"оператор in\",\n  \"Python\",\n  \"сравнение коллекций\",\n  \"итерация по кортежу\",\n  \"булевы операции\",\n  \"логическое И\",\n  \"проверка подмножества\",\n  \"contains_all\",\n  \"эффективность\",\n  \"короткое замыкание\",\n  \"встроенные функции\",\n  \"проверка принадлежности\"\n]"
  },
  {
    "question": "Что такое асинхронный код?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Асинхронный код - это подход к написанию кода, который позволяет выполнять несколько задач одновременно в рамках одного процесса. Это достигается за счет использования асинхронных функций и корутин. В отличие от синхронного кода, который выполняет каждую задачу последовательно, асинхронный код может запустить несколько задач \"параллельно\" и организовать их выполнение с помощью итераций и вызовов коллбеков.",
    "code_snippet": "second_tuple = (2, 4, 5)",
    "key_terms": "[\n  \"асинхронный код\",\n  \"асинхронное программирование\",\n  \"корутины\",\n  \"async\",\n  \"await\",\n  \"параллельное выполнение задач\",\n  \"неблокирующий ввод-вывод\",\n  \"событийный цикл\",\n  \"asyncio\",\n  \"асинхронные функции\",\n  \"однопоточное многозадачность\",\n  \"эффективность\",\n  \"синхронный код\",\n  \"блокирующие операции\",\n  \"сетевые запросы\",\n  \"обработка ввода-вывода\",\n  \"асинхронные генераторы\",\n  \"асинхронные менеджеры контекста\",\n  \"короткое замыкание задач\",\n  \"увеличение производительности\",\n  \"одновременное выполнение\",\n  \"Python\",\n  \"асинхронные библиотеки\",\n  \"управление задачами\"\n]"
  },
  {
    "question": "Можно ли использовать несколько декораторов для одной функции?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Да, в Python можно использовать несколько декораторов для одной функции. Это называется стеком декораторов. \nКогда функция декорируется несколькими декораторами, они применяются к функции в порядке, в котором они указаны сверху вниз.",
    "code_snippet": "contains_all = all(elem in first_tuple for elem in second_tuple)",
    "key_terms": "[\n  \"декораторы\",\n  \"несколько декораторов\",\n  \"стек декораторов\",\n  \"порядок применения\",\n  \"вложенные декораторы\",\n  \"Python\",\n  \"оборачивание функций\",\n  \"синтаксис @\",\n  \"wrapper\",\n  \"функция обертка\",\n  \"decorator1(decorator2(func))\",\n  \"последовательность вызовов\",\n  \"эффекты декораторов\",\n  \"управление поведением функции\",\n  \"повторное использование кода\",\n  \"изменение поведения без изменения кода\",\n  \"пример с HTML тегами\",\n  \"repeater\",\n  \"delayed\",\n  \"влияние порядка декораторов\",\n  \"композиция функций\",\n  \"декораторы с аргументами\"\n]"
  },
  {
    "question": "В чем разница между copy и deepcopy?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "copy() - это функция используется для создания поверхностной копии. \nПоверхностная копия создает новый объект, но копирует только ссылки на элементы из оригинального объекта, а не копирует сами элементы.\n\ndeepcopy() - это функция используется для создания глубокой копии объекта.\nГлубокая копия создает новый объект и рекурсивно копирует все элементы во всех вложенных структурах данных. Изменения в глубокой копии не влияют на оригинал, и наоборот.",
    "code_snippet": "",
    "key_terms": "[\n  \"copy\",\n  \"deepcopy\",\n  \"поверхностное копирование\",\n  \"глубокое копирование\",\n  \"новый объект\",\n  \"ссылки на вложенные объекты\",\n  \"рекурсивное копирование\",\n  \"вложенные структуры данных\",\n  \"изменяемые объекты\",\n  \"Python\",\n  \"модуль copy\",\n  \"эффект изменений\",\n  \"отдельная копия\",\n  \"память и производительность\",\n  \"copy.copy()\",\n  \"copy.deepcopy()\",\n  \"независимость копий\",\n  \"изменение оригинала\",\n  \"изменение копии\",\n  \"примеры использования\",\n  \"сложные объекты\",\n  \"списки и словари\",\n  \"ограничения deepcopy\",\n  \"рекурсия\"\n]"
  },
  {
    "question": "Как понять хэшируемый ли объект?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Объект называется хешируемым, если он имеет хеш-значение (целое число), которое никогда не изменяется на протяжении его жизненного цикла и возвращается методом __hash__(), и может сравниваться с другими объектами (реализует метод __eq__()). \nРавные хешируемые объекты должны иметь равные хеш-значения.\nВсе стандартные неизменяемые объекты хешируемые. Все стандартные изменяемые объекты не хешируемые.",
    "code_snippet": "",
    "key_terms": "[\n  \"хэшируемый объект\",\n  \"hashable\",\n  \"__hash__\",\n  \"__eq__\",\n  \"хеш-значение\",\n  \"неизменяемость\",\n  \"жизненный цикл объекта\",\n  \"сравнение объектов\",\n  \"равенство хешей\",\n  \"стандартные типы Python\",\n  \"изменяемые объекты\",\n  \"неизменяемые объекты\",\n  \"использование в словарях\",\n  \"использование в множествах\",\n  \"контракт хеширования\",\n  \"уникальность хеша\",\n  \"поведение методов\",\n  \"проверка хэшируемости\",\n  \"функция hash()\",\n  \"исключения TypeError\",\n  \"ключи словарей\",\n  \"множества\",\n  \"эффективность поиска\"\n]"
  },
  {
    "question": "Что такое дандер методы?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Дандер методы (магические методы) - это специальные методы, имена которых начинаются и заканчиваются двойными подчеркиваниями.  \nНапример, __init__\nЭти методы предоставляют специальное поведение для классов и позволяют переопределять стандартные операции, такие как инициализация объектов, арифметические операции и другие",
    "code_snippet": "",
    "key_terms": "[\n  \"дандер методы\",\n  \"магические методы\",\n  \"специальные методы\",\n  \"двойное подчеркивание\",\n  \"__init__\",\n  \"__call__\",\n  \"__getitem__\",\n  \"__setitem__\",\n  \"переопределение операций\",\n  \"инициализация объектов\",\n  \"перегрузка операторов\",\n  \"Python\",\n  \"поведение классов\",\n  \"встроенные методы\",\n  \"объекты\",\n  \"строковое представление\",\n  \"__str__\",\n  \"итерация\",\n  \"__iter__\",\n  \"__next__\",\n  \"сравнение объектов\",\n  \"__eq__\",\n  \"__add__\",\n  \"контроль доступа к элементам\",\n  \"создание вызываемых объектов\",\n  \"настройка поведения\",\n  \"интуитивное использование классов\"\n]"
  },
  {
    "question": "Как реализуется управление памятью в python?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "Управление памятью осуществляется автоматически с помощью механизма сборки мусора (Garbage collector). Когда объект в Python больше не нужен (например, после того как на него уже нет ссылок), он помечается как garbage (мусор), после чего он будет автоматически удален при следующем запуске сборщика мусора.\nМодуль gc в Python также предлагает дополнительный функционал для управления памятью. Например, метод gc.collect() позволяет сделать принудительную сборку мусора.",
    "code_snippet": "",
    "key_terms": "[\n  \"управление памятью\",\n  \"сборка мусора\",\n  \"Garbage Collector\",\n  \"подсчет ссылок\",\n  \"reference counting\",\n  \"сборка циклических ссылок\",\n  \"cycle detection\",\n  \"поколенческая сборка мусора\",\n  \"mark and sweep\",\n  \"модуль gc\",\n  \"gc.collect()\",\n  \"автоматическое освобождение памяти\",\n  \"удаление объектов без ссылок\",\n  \"ручное управление сборкой мусора\",\n  \"gc.disable()\",\n  \"gc.enable()\",\n  \"жизненный цикл объектов\",\n  \"утечки памяти\",\n  \"эффективность использования памяти\",\n  \"Python\",\n  \"системные ресурсы\",\n  \"фоновый режим сборщика мусора\",\n  \"stop-the-world паузы\",\n  \"сборка мусора на основе поколений\",\n  \"счетчики аллокаций и деаллокаций\"\n]"
  },
  {
    "question": "Зачем в python используется ключевое слово self?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "В Python ключевое слово self используется для обращения к текущему объекту класса. Оно передается как первый аргумент в методы класса и позволяет работать с атрибутами и методами объекта класса внутри этих методов.",
    "code_snippet": "",
    "key_terms": "[\n  \"self\",\n  \"ключевое слово\",\n  \"экземпляр класса\",\n  \"ссылка на объект\",\n  \"первый аргумент метода\",\n  \"доступ к атрибутам\",\n  \"доступ к методам\",\n  \"объектно-ориентированное программирование\",\n  \"Python\",\n  \"соглашение об именовании\",\n  \"не зарезервированное слово\",\n  \"явное указание self\",\n  \"инициализация объекта\",\n  \"__init__\",\n  \"вызов методов класса\",\n  \"работа с атрибутами экземпляра\",\n  \"передача self автоматически\",\n  \"уникальные данные объекта\",\n  \"гибкость кода\",\n  \"читаемость кода\",\n  \"пример использования\",\n  \"методы класса\",\n  \"ссылка на текущий объект\",\n  \"отличие от локальных переменных\"\n]"
  },
  {
    "question": "Сколько может быть родителей и наследников у класса?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "В Python класс может иметь любое количество родительских классов и любоек количество наследников. Python поддерживает множественное наследование.",
    "code_snippet": "",
    "key_terms": "[\n  \"родители класса\",\n  \"наследники класса\",\n  \"множественное наследование\",\n  \"Python\",\n  \"количество родителей\",\n  \"количество наследников\",\n  \"множественные суперклассы\",\n  \"порядок наследования\",\n  \"проблема ромбов\",\n  \"алгоритм MRO\",\n  \"линейное разрешение методов\",\n  \"super()\",\n  \"конфликты наследования\",\n  \"diamond problem\",\n  \"структура иерархии классов\",\n  \"перегрузка методов\",\n  \"вызов методов родителей\",\n  \"наследование от object\",\n  \"композиция vs наследование\",\n  \"ограничения наследования\",\n  \"динамическое наследование\",\n  \"переопределение методов\",\n  \"многоуровневое наследование\",\n  \"управление поведением классов\"\n]"
  },
  {
    "question": "Что такое reduce() ?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "reduce() применяет указанную функцию к элементам последовательности слева направо с аккумулированием результатов. Он возвращает одно значение, а не итератор. \nНапример: \nnum = [1,2,3,4,5]\nsum_of = reduce(lambda x,y: x+y, num)\nOutput: 15",
    "code_snippet": "",
    "key_terms": "[\n  \"reduce\",\n  \"functools\",\n  \"функция высшего порядка\",\n  \"кумулятивное применение функции\",\n  \"итерация слева направо\",\n  \"агрегация данных\",\n  \"функция с двумя аргументами\",\n  \"итерируемый объект\",\n  \"начальное значение аккумулятора\",\n  \"lambda функции\",\n  \"сведение последовательности к одному значению\",\n  \"аккумулятор\",\n  \"примеры использования\",\n  \"суммирование элементов\",\n  \"умножение элементов\",\n  \"нахождение максимума\",\n  \"эффективность\",\n  \"короткое замыкание\",\n  \"обработка пустых последовательностей\",\n  \"альтернатива циклам\",\n  \"Python\",\n  \"модуль functools\",\n  \"функциональное программирование\",\n  \"применение к спискам и другим коллекциям\"\n]"
  },
  {
    "question": "Что такое взрыв и затухание градиента?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Градиентный спуск — метод нахождения локального минимума или максимума функции с помощью движения вдоль градиента.\n\nГрадиент — это вектор, своим направлением указывающий направление наибольшего \nвозрастания некоторой скалярной величины, а по модулю равный скорости \nроста этой величины в этом направлении.\n\nГрадиент функции — это вектор, координатами которого являются частные производные этой функции по всем её переменным. Направление градиента есть направление \nнаибыстрейшего возрастания функции, то есть производная функции (а точнее её знак) показывает, в каком направлении функции возрастает.\n**Этапы градиентного спуска для функции нескольких переменных:**\n\n1. Инициализируемся в случайной точке $x_{start}$.\n2. Спускаемся до сходимости модели.\n3. Останавливаемся тогда, когда значение производной становится очень маленьким (те же три варианта порога).\n\nЗатухание градиента — слишком маленькая длина шага приводит к раннему срабатыванию критерия останова.\n«Взрыв» градиента — бесконечно блуждание по функции без схождения градиента.",
    "code_snippet": "",
    "key_terms": "[\n  \"градиентный спуск\",\n  \"градиент\",\n  \"вектор градиента\",\n  \"частные производные\",\n  \"направление наибольшего возрастания\",\n  \"скорость роста функции\",\n  \"локальный минимум\",\n  \"локальный максимум\",\n  \"итеративный метод\",\n  \"затухание градиента\",\n  \"слишком маленький шаг\",\n  \"ранний останов\",\n  \"взрыв градиента\",\n  \"бесконечное блуждание\",\n  \"несходимость\",\n  \"обучение нейронных сетей\",\n  \"численные методы оптимизации\",\n  \"шаг градиентного спуска\",\n  \"критерий останова\",\n  \"производная функции\",\n  \"оптимизация\",\n  \"переобучение\",\n  \"переход к минимуму\",\n  \"ускорение сходимости\"\n]"
  },
  {
    "question": "Опишите жадный алгоритм построения дерева",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Шаг 1: Начинаем построение с корня.\nШаг 2: Ищем лучший предикат и смотрим на новые разбиения.\nШаг 3: Проваливаемся в новые вершины.\nШаг 4: Если выполнен критерий останова, то даем прогноз.\nШаг 5: Иначе – для выбранной вершины повторяем Шаги 2-5",
    "code_snippet": "",
    "key_terms": "[\n  \"жадный алгоритм\",\n  \"построение дерева\",\n  \"корень дерева\",\n  \"предикат\",\n  \"разбиение данных\",\n  \"ветвление\",\n  \"вершины дерева\",\n  \"критерий останова\",\n  \"прогноз\",\n  \"рекурсивное построение\",\n  \"жадный выбор\",\n  \"оптимизация локального шага\",\n  \"дерево решений\",\n  \"обучение модели\",\n  \"разделение признаков\",\n  \"условия разбиения\",\n  \"жадный подход\",\n  \"обход дерева\",\n  \"переобучение\",\n  \"упрощение модели\",\n  \"эффективность алгоритма\",\n  \"ограничение глубины\",\n  \"критерии качества разбиения\",\n  \"индуктивное обучение\"\n]"
  },
  {
    "question": "Отличия логистической регрессии и SVM",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Метод опорных векторов(SVM - Support Vector Machine) - способ построения модели классификации, суть которого заключается в построении разделяющей гиперплоскости.\nВ отличии от логистической регрессии, данный алгоритм работает в предположении, что чем больше расстояние (зазор) между разделяющей гиперплоскостью и объектами разделяемых классов, тем меньше будет средняя ошибка классификатора.\nПри этом гиперплоскость должна пройти так, чтобы расстояние до ближайшего объекта было максимальным.\nLR старается как можно корректнее оценить вероятности, когда SVM максимизирует все зазоры между гиперплоскостью и границами классов.\nФормально оба подхода классификации решают похожие задачи. \nСравним SVM с методом логистической регресии:\n\n- SVM  является частным случаем минимизации индикаторов отступов со специфической верхней оценкой и модификацией в виде регуляризации.\n- В отличии от логистической регрессии, он не учитывает вероятности и не стремится к максимизации уверенности в прогнозе.\n- Его основная задача - построение разделяющей гиперплоскости с достаточно широкой полосой.\n- Функция потерь для SVM носит название hinge loss\n- При этом мы все еще можем оценить вероятность с помощью метода калибровки.",
    "code_snippet": "",
    "key_terms": "[\n  \"логистическая регрессия\",\n  \"SVM\",\n  \"метод опорных векторов\",\n  \"разделяющая гиперплоскость\",\n  \"максимизация зазора\",\n  \"margin\",\n  \"hinge loss\",\n  \"функция потерь\",\n  \"оценка вероятностей\",\n  \"калибровка вероятностей\",\n  \"регуляризация\",\n  \"минимизация ошибки\",\n  \"классификация\",\n  \"линейный классификатор\",\n  \"отступ классификации\",\n  \"оптимизация\",\n  \"градиентный спуск\",\n  \"максимизация уверенности\",\n  \"различия в подходах\",\n  \"предсказание классов\",\n  \"прогноз вероятностей\",\n  \"обучение моделей\",\n  \"задача классификации\",\n  \"регрессия\"\n]"
  },
  {
    "question": "Что такое кросс-валидация",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Кросс-валидация (перекрестная проверка, скользящий контроль) – это метод оценки обобщающей способности модели. Кросс-Валидация делит выборку на несколько блоков, обучает модель на всех кроме одного, и на нем же происходит замер качества. Самый популярный способ – Kfold:  \n- Представим, что у нас есть некий набор данных. Делим исходные данные на k фолдов(частей) примерно одинаково размера.\n- Затем на (k - 1) блоке обучаем модели, а оставшуюся часть используем для тестирования.\n- Повторяем процедуру k раз, при этом на каждой итерации для проверки выбирается новый блок, а обучение производится на оставшихся.\n- Замеряем k средних ошибок на валидационной выборке (ее мы отложили ранее) и если их среднее/их распределение нас устраивает, то строим финальную модель",
    "code_snippet": "",
    "key_terms": "[\n  \"кросс-валидация\",\n  \"перекрестная проверка\",\n  \"skользящий контроль\",\n  \"оценка модели\",\n  \"обобщающая способность\",\n  \"разбиение данных\",\n  \"k-fold\",\n  \"фолды\",\n  \"обучающая выборка\",\n  \"валидационная выборка\",\n  \"тестирование модели\",\n  \"итеративное обучение\",\n  \"средняя ошибка\",\n  \"оценка качества\",\n  \"устойчивость модели\",\n  \"предотвращение переобучения\",\n  \"разделение данных\",\n  \"перекрестное тестирование\",\n  \"выбор параметров\",\n  \"финальная модель\",\n  \"статистическая оценка\",\n  \"перекрестная проверка\",\n  \"размер блоков\",\n  \"повторяемость эксперимента\"\n]"
  },
  {
    "question": "Что такое мультиколлинеарность и как бороться?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Мультиколлинеарность - наличие линейной завивимости между признаками, т.е. когда можно выразить один признак через другой. Это приводит к целому комплексу проблем (например, неустойчивости модели и очень часто к переобучению модели).\nТак как мы работаем с признаками как с векторами, когда среди них присутствуют такие, которые можно выразить через другие признаки, появляется проблема мультиколлинеарности. \n\nМультиколлинеарность можно также обозначить как избыточность признаков, то есть убрав один из таких признаков мы не лишимся какой-либо важной информации. Т.е, можно бороться с мультиколлинеарностью с помощью отбора признаков и регуляризации \n\nРазличают слабую мультиколлинеарность и сильную. Сильная мультиколлинеарность  возникает когда есть сильная линейная зависимость между колонками. Слабая возникает когда линейная связь между колонками присутствует, но она зашумлена.",
    "code_snippet": "",
    "key_terms": "[\n  \"мультиколлинеарность\",\n  \"линейная зависимость признаков\",\n  \"корреляция признаков\",\n  \"избыточность признаков\",\n  \"сильная мультиколлинеарность\",\n  \"слабая мультиколлинеарность\",\n  \"коэффициент корреляции Пирсона\",\n  \"порог корреляции\",\n  \"неустойчивость модели\",\n  \"переобучение\",\n  \"отбор признаков\",\n  \"регуляризация\",\n  \"матрица корреляций\",\n  \"определитель матрицы корреляций\",\n  \"статистическая значимость коэффициентов\",\n  \"множественная регрессия\",\n  \"ошибки оценки параметров\",\n  \"интерпретация модели\",\n  \"стандартные ошибки\",\n  \"устойчивость коэффициентов\",\n  \"исключение признаков\",\n  \"улучшение метрик модели\",\n  \"проблемы линейной регрессии\",\n  \"снижение точности оценок\"\n]"
  },
  {
    "question": "Чем отличается Lasso от Ridge регуляризации?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Регуляризировать модель это значит в минимизируемый функционал добавить норму от вектора коэффициентов. \nВыделяют два типа:\n L-2(Ridge) -  когда мы в качестве регуляризатора берем сумму квадратов всех параметров модели \nL-1(Lasso) -  когда мы в качестве регуляризатора берем сумму модулей всех параметров модели \nОтличие Lasso-регуляризации от Ridge-регуляризации, заключается в том, что она склонна занулять некоторые коэффициенты.",
    "code_snippet": "",
    "key_terms": "[\n  \"Lasso\",\n  \"Ridge\",\n  \"регуляризация\",\n  \"L1-норма\",\n  \"L2-норма\",\n  \"сумма модулей коэффициентов\",\n  \"сумма квадратов коэффициентов\",\n  \"зануление коэффициентов\",\n  \"шардинг признаков\",\n  \"устранение мультиколлинеарности\",\n  \"сжатие коэффициентов\",\n  \"спарсити\",\n  \"отбор признаков\",\n  \"устойчивость модели\",\n  \"предотвращение переобучения\",\n  \"регуляризатор\",\n  \"минимизация функции потерь\",\n  \"линейная регрессия\",\n  \"коэффициенты модели\",\n  \"эффект регуляризации\",\n  \"гиперпараметры\",\n  \"алгоритмы оптимизации\",\n  \"интерпретируемость модели\",\n  \"различия L1 и L2\",\n  \"применение в машинном обучении\"\n]"
  },
  {
    "question": "Назовите компоненты классической ML задачи",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "* Выборка\n* Ответ (target)\n* Функция потерь и функционал качества\n* Метрики качества\n* Алгоритм\\семейство моделей\n* Оценка модели",
    "code_snippet": "",
    "key_terms": "[\n  \"выборка\",\n  \"данные\",\n  \"ответ\",\n  \"target\",\n  \"функция потерь\",\n  \"функционал качества\",\n  \"метрики качества\",\n  \"оценка модели\",\n  \"алгоритм\",\n  \"семейство моделей\",\n  \"обучение модели\",\n  \"валидация\",\n  \"тестирование\",\n  \"обобщающая способность\",\n  \"переобучение\",\n  \"недообучение\",\n  \"предобработка данных\",\n  \"разделение на обучающую и тестовую выборки\",\n  \"гиперпараметры\",\n  \"оптимизация\",\n  \"кросс-валидация\",\n  \"оценка производительности\",\n  \"целевые переменные\",\n  \"прогнозирование\"\n]"
  },
  {
    "question": "Разница между precision и recall",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Precision и Recall это две самые популярные метрики.\nPrecision (точность) позволяет понять, какая доля объектов среди тех, которые мы назвали положительным классом, действительно к нему относится.\nRecall (полнота) же показывает, сколько объектов среди тех, которые в общем были положительные, наша модель смогла выявить.",
    "code_snippet": "",
    "key_terms": "[\n  \"precision\",\n  \"точность\",\n  \"recall\",\n  \"полнота\",\n  \"метрики качества\",\n  \"положительный класс\",\n  \"истинные положительные\",\n  \"ложные положительные\",\n  \"ложные отрицательные\",\n  \"TP\",\n  \"FP\",\n  \"FN\",\n  \"оценка классификатора\",\n  \"баланс между precision и recall\",\n  \"f1-score\",\n  \"чувствительность\",\n  \"специфичность\",\n  \"ошибки первого рода\",\n  \"ошибки второго рода\",\n  \"применение в классификации\",\n  \"анализ результатов\",\n  \"модель машинного обучения\",\n  \"классификация бинарная\",\n  \"порог классификации\"\n]"
  },
  {
    "question": "Чем отличается метрика от Loss?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Loss-функция это функция позволяющая замерить ошибку алгоритма на одном наблюдении. \nОбычно сумму loss’ов по всем объектам оптимизируют, обучая модели.\nМетрика – финальный замер качества алгоритмов, по ней производятся презентации и отбор модели.",
    "code_snippet": "",
    "key_terms": "[\n  \"метрика\",\n  \"loss\",\n  \"функция потерь\",\n  \"ошибка на одном наблюдении\",\n  \"суммарная ошибка\",\n  \"оптимизация модели\",\n  \"оценка качества\",\n  \"обучение модели\",\n  \"финальный замер\",\n  \"презентация результатов\",\n  \"отбор модели\",\n  \"различия между метрикой и loss\",\n  \"функционал качества\",\n  \"целевые функции\",\n  \"градиентный спуск\",\n  \"обратное распространение ошибки\",\n  \"сравнение моделей\",\n  \"показатели производительности\",\n  \"объективность оценки\",\n  \"применение в машинном обучении\",\n  \"ошибки классификации\",\n  \"регрессия\",\n  \"классификация\",\n  \"средняя ошибка\",\n  \"интерпретируемость\"\n]"
  },
  {
    "question": "Как выбрать число k для алгоритма кластеризации «метод k-средних» (k-Means Clustering), не смотря на кластеры?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Есть два метода выбора значения k для метода k-средних. Первый – это «метод локтя». Строится график зависимости функции потерь от количества кластеров k, и если представить, что график – это «рука», то лучшее значение количества кластеров будет там, где «локоть» этой «руки».\nОднако, это не всегда так очевидно, поэтому в тех случаях, когда это не так, используется метод силуэта. Этот метод использует «рейтинг силуэта», находящийся в диапазоне от -1 до 1 для каждого количества кластеров. Количество кластеров с максимальным рейтингом обычно является оптимальным.",
    "code_snippet": "",
    "key_terms": "[\n  \"k-средних\",\n  \"k-Means Clustering\",\n  \"выбор числа k\",\n  \"количество кластеров\",\n  \"метод локтя\",\n  \"график функции потерь\",\n  \"внутрикластерная дисперсия\",\n  \"локоть на графике\",\n  \"оптимальное количество кластеров\",\n  \"метод силуэта\",\n  \"рейтинг силуэта\",\n  \"коэффициент силуэта\",\n  \"диапазон от -1 до 1\",\n  \"оценка качества кластеризации\",\n  \"максимизация рейтинга силуэта\",\n  \"кластеризация\",\n  \"функция потерь\",\n  \"центроиды кластеров\",\n  \"анализ кластеров\",\n  \"визуализация\",\n  \"разделение данных\",\n  \"устойчивость кластеров\",\n  \"оптимизация параметров\",\n  \"машинное обучение\"\n]"
  },
  {
    "question": "Объясните алгоритм машинного обучения SVM",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "SVM, или метод опорных векторов, — это набор алгоритмов обучения с учителем, который используется для классификации и регрессионного анализа. \nЕго основная идея — построение гиперплоскости, которая разделяет объекты выборки максимально эффективным способом. Сделать это можно с помощью алгоритма линейной классификации.",
    "code_snippet": "",
    "key_terms": "[\n  \"SVM\",\n  \"метод опорных векторов\",\n  \"машинное обучение\",\n  \"обучение с учителем\",\n  \"классификация\",\n  \"регрессия\",\n  \"гиперплоскость\",\n  \"разделение классов\",\n  \"максимизация зазора\",\n  \"опорные векторы\",\n  \"зазор (margin)\",\n  \"линейная классификация\",\n  \"линейно-разделимые данные\",\n  \"мягкая граница (soft margin)\",\n  \"ошибки классификации\",\n  \"квадратичное программирование\",\n  \"ядра (kernel)\",\n  \"нелинейное преобразование\",\n  \"линейное пространство признаков\",\n  \"полиномиальное ядро\",\n  \"радиально-базисное ядро (RBF)\",\n  \"оптимальная разделяющая гиперплоскость\",\n  \"обучающий набор данных\",\n  \"расстояние до гиперплоскости\",\n  \"прогнозирование класса\",\n  \"эффективность памяти\",\n  \"применение в задачах классификации\",\n  \"обработка многомерных данных\"\n]"
  },
  {
    "question": "Что такое Random Forest?",
    "category": "Data Science",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Random Forest, или случайный лес, — это один из немногих универсальных алгоритмов обучения, который способен выполнять задачи классификации, регрессии и кластеризации. \nСлучайный лес состоит из большого количества отдельных деревьев решений, которые по сути являются ансамблем методов. Каждое дерево в случайном лесу возвращает прогноз класса, и класс с наибольшим количеством голосов становится прогнозом леса.",
    "code_snippet": "",
    "key_terms": "[\n  \"Random Forest\",\n  \"случайный лес\",\n  \"ансамбль моделей\",\n  \"деревья решений\",\n  \"классификация\",\n  \"регрессия\",\n  \"кластеризация\",\n  \"обучение с учителем\",\n  \"бэггинг\",\n  \"случайный отбор признаков\",\n  \"агрегация голосов\",\n  \"прогноз класса\",\n  \"усреднение результатов\",\n  \"уменьшение переобучения\",\n  \"устойчивость модели\",\n  \"случайные подмножества данных\",\n  \"случайные подмножества признаков\",\n  \"обобщающая способность\",\n  \"вычислительная эффективность\",\n  \"обработка больших данных\",\n  \"интерпретируемость\",\n  \"важность признаков\",\n  \"применение в машинном обучении\",\n  \"надежность\",\n  \"стохастический алгоритм\"\n]"
  },
  {
    "question": "Расскажите про принципы ООП?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "ООП означает \"Объектно-ориентированное программирование\". Это парадигма программирования, которая ставит в центр разработки программ объекты и их взаимодействие. В ООП, программа рассматривается как набор взаимодействующих между собой объектов, каждый из которых представляет реальный объект или абстракцию.\n\nОсновные принципы ООП включают:\n1)Инкапсуляция: Объекты могут скрывать свою внутреннюю реализацию и предоставлять интерфейс для взаимодействия с внешним миром. Это позволяет изменять внутреннюю реализацию объекта без влияния на внешний код.\n2)Наследование: Один класс может наследовать свойства и методы от другого класса. Наследование позволяет создавать иерархию классов, где дочерние классы получают функциональность родительских классов.\n3)Полиморфизм: Это позволяет объектам различных классов иметь одинаковый интерфейс, но различную реализацию. Полиморфизм позволяет использовать объекты разных типов с одним и тем же интерфейсом.\n4)Абстракция: Это позволяет создавать абстрактные классы и интерфейсы, которые определяют общий набор функциональности, но не содержат конкретной реализации. Абстракция помогает создавать модели и обобщенные концепции, упрощая сложные системы.",
    "code_snippet": "",
    "key_terms": "[\n  \"объектно-ориентированное программирование\",\n  \"ООП\",\n  \"объекты\",\n  \"классы\",\n  \"инкапсуляция\",\n  \"наследование\",\n  \"полиморфизм\",\n  \"абстракция\",\n  \"взаимодействие объектов\",\n  \"скрытие данных\",\n  \"публичный интерфейс\",\n  \"иерархия классов\",\n  \"переиспользование кода\",\n  \"разделение ответственности\",\n  \"моделирование реального мира\",\n  \"наследование свойств и методов\",\n  \"различные реализации интерфейса\",\n  \"абстрактные классы\",\n  \"интерфейсы\",\n  \"безопасность данных\",\n  \"упрощение сложных систем\",\n  \"объектно-ориентированный подход\",\n  \"экземпляры классов\",\n  \"поведение объектов\"\n]"
  },
  {
    "question": "Что такое JWT?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "JWT расшифровывается как \"JSON Web Token\" (токен веба на основе JSON). Это открытый стандарт (RFC 7519), который определяет компактный и самодостаточный способ представления информации между двумя сторонами в формате JSON. JWT часто используется для передачи данных аутентификации и авторизации между клиентом и сервером в безопасной и компактной форме.\n\nJWT состоит из трех частей:\n\nЗаголовок (Header): Содержит информацию о типе токена (часто это JWT) и алгоритме шифрования, используемом для создания подписи. Обычно выглядит так:\nПолезная нагрузка (Payload): Это место, где хранится сама информация токена. В JWT эта информация представляется в виде JSON и может включать любые данные, которые нужно передать между клиентом и сервером. Такие данные могут быть, например, идентификатор пользователя, срок действия токена, разрешения и прочее.\nПодпись (Signature): Подпись используется для проверки подлинности токена и обеспечивает его целостность. Он создается путем объединения заголовка и полезной нагрузки, а затем подписывается секретным ключом, который хранится на сервере. Таким образом, сервер может проверить, не были ли данные токена изменены в процессе передачи.",
    "code_snippet": "",
    "key_terms": "[\n  \"JWT\",\n  \"JSON Web Token\",\n  \"открытый стандарт RFC 7519\",\n  \"токен доступа\",\n  \"аутентификация\",\n  \"авторизация\",\n  \"клиент-серверное взаимодействие\",\n  \"заголовок (Header)\",\n  \"тип токена\",\n  \"алгоритм шифрования\",\n  \"полезная нагрузка (Payload)\",\n  \"данные токена\",\n  \"идентификатор пользователя\",\n  \"срок действия токена\",\n  \"разрешения\",\n  \"подпись (Signature)\",\n  \"проверка подлинности\",\n  \"целостность данных\",\n  \"секретный ключ\",\n  \"подпись токена\",\n  \"Base64-URL кодирование\",\n  \"Access Token\",\n  \"Refresh Token\",\n  \"безопасная передача данных\",\n  \"локальное хранилище\",\n  \"HTTP-заголовок Authorization\",\n  \"авторизация запросов\",\n  \"масштабируемость\",\n  \"производительность\",\n  \"защита от подделки\",\n  \"самодостаточный токен\"\n]"
  },
  {
    "question": "Что такое MVC?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "MVC (Model-View-Controller): MVC - это архитектурный паттерн, который разделяет веб-приложение на три основных компонента:\nМодель (Model): Этот компонент отвечает за обработку данных и бизнес-логику приложения. Он представляет собой представление данных, с которыми работает приложение, и обеспечивает их доступ и манипуляции.\nПредставление (View): Этот компонент отвечает за отображение данных пользователю и интерактивность интерфейса. Он получает информацию из модели и готовит ее для отображения пользователю.\nКонтроллер (Controller): Этот компонент управляет взаимодействием между моделью и представлением. Он обрабатывает входящие запросы от пользователя, вызывает соответствующие методы модели и подготавливает данные для отображения в представлении.",
    "code_snippet": "",
    "key_terms": "[\n  \"MVC\",\n  \"Model-View-Controller\",\n  \"архитектурный паттерн\",\n  \"модель (Model)\",\n  \"представление (View)\",\n  \"контроллер (Controller)\",\n  \"разделение ответственности\",\n  \"бизнес-логика\",\n  \"обработка данных\",\n  \"визуализация данных\",\n  \"пользовательский интерфейс\",\n  \"взаимодействие пользователя\",\n  \"обработка запросов\",\n  \"связь между моделью и представлением\",\n  \"независимость компонентов\",\n  \"масштабируемость\",\n  \"поддерживаемость кода\",\n  \"модульность\",\n  \"обновление интерфейса\",\n  \"изменение бизнес-логики\",\n  \"динамические веб-приложения\",\n  \"разработка ПО\",\n  \"обработка пользовательского ввода\",\n  \"обработка событий\",\n  \"логика приложения\",\n  \"представление данных\",\n  \"разработка командой\",\n  \"тестируемость\",\n  \"гибкость архитектуры\"\n]"
  },
  {
    "question": "Что такое CRUD?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Терамин обозначающий четыре базовые функции: создание (create), чтение (read), редактирование (update) и удаление (delete). Как правило, термин \"CRUD\" употребляется в контексте работы с хранилищем данных.",
    "code_snippet": "",
    "key_terms": "[\n  \"CRUD\",\n  \"create\",\n  \"read\",\n  \"update\",\n  \"delete\",\n  \"базовые операции\",\n  \"управление данными\",\n  \"хранилище данных\",\n  \"создание записи\",\n  \"чтение данных\",\n  \"обновление записи\",\n  \"удаление записи\",\n  \"базы данных\",\n  \"веб-приложения\",\n  \"API\",\n  \"HTTP методы\",\n  \"POST\",\n  \"GET\",\n  \"PATCH\",\n  \"PUT\",\n  \"DELETE\",\n  \"интерфейс пользователя\",\n  \"формы ввода\",\n  \"работа с данными\",\n  \"обработка запросов\",\n  \"администрирование\",\n  \"управление информацией\",\n  \"программирование\",\n  \"системы управления данными\"\n]"
  },
  {
    "question": "Что такое DRY?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "Это аббревиатура от фразы \"Do not Repeat Yourself\" (не повторяйся), которая описывает принцип проектирования программного обеспечения, который заключается в том, чтобы избегать дублирования кода и логики в разных частях системы.",
    "code_snippet": "",
    "key_terms": "[\n  \"DRY\",\n  \"Don't Repeat Yourself\",\n  \"принцип разработки ПО\",\n  \"избегание дублирования кода\",\n  \"единственное представление знания\",\n  \"снижение повторения информации\",\n  \"управляемая архитектура\",\n  \"модульность\",\n  \"повышение сопровождаемости\",\n  \"упрощение внесения изменений\",\n  \"качественное тестирование\",\n  \"повторное использование кода\",\n  \"генераторы кода\",\n  \"автоматические системы сборки\",\n  \"Single Source of Truth\",\n  \"логика работы\",\n  \"функции и методы\",\n  \"архитектурные паттерны\",\n  \"согласованность изменений\",\n  \"устранение копипаста\",\n  \"повышение читаемости кода\",\n  \"масштабируемость проекта\",\n  \"разделение ответственности\",\n  \"программирование\",\n  \"примеры применения\",\n  \"принцип Энди Ханта и Дэйва Томаса\",\n  \"устойчивость к ошибкам\",\n  \"оптимизация разработки\",\n  \"снижение технического долга\"\n]"
  },
  {
    "question": "Что такое SOLID?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "\"SOLID\" - это аббревиатура, представляющая собой первые буквы пяти основных принципов объектно-ориентированного программирования и проектирования. Эти принципы помогают разработчикам создавать гибкие, поддерживаемые и масштабируемые программные системы. SOLID был представлен Робертом Мартином и Майклом Фезерсом как мнемоническое устройство для запоминания этих принципов.\n\nПринцип единственной ответственности (Single Responsibility Principle - SRP): Каждый класс должен иметь только одну причину для изменения. Это означает, что класс должен быть ответственен только за одну четко определенную функциональность или задачу.\nПринцип открытости/закрытости (Open/Closed Principle - OCP): Сущности программы должны быть открыты для расширения, но закрыты для изменения. Это можно достичь путем использования абстракций, интерфейсов и наследования, чтобы изменять поведение программы без изменения исходного кода.\nПринцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP): Объекты базовых классов должны быть заменяемыми своими подклассами без нарушения корректности программы. То есть, код, использующий базовый класс, должен корректно работать с любым его подклассом, не зная об этом.\nПринцип разделения интерфейса (Interface Segregation Principle - ISP): Много специализированных интерфейсов лучше, чем один универсальный. Клиенты не должны зависеть от интерфейсов, которые они не используют, и классы должны предоставлять только те методы, которые требуются клиентам.\nПринцип инверсии зависимостей (Dependency Inversion Principle - DIP): Зависимости должны строиться на абстракциях, а не на конкретных реализациях. Высокоуровневые модули не должны зависеть от низкоуровневых модулей, а оба типа модулей должны зависеть от абстракций.",
    "code_snippet": "",
    "key_terms": "[\n  \"SOLID\",\n  \"принципы объектно-ориентированного программирования\",\n  \"Robert C. Martin\",\n  \"Michael Feathers\",\n  \"Single Responsibility Principle (SRP)\",\n  \"принцип единственной ответственности\",\n  \"Open/Closed Principle (OCP)\",\n  \"принцип открытости/закрытости\",\n  \"Liskov Substitution Principle (LSP)\",\n  \"принцип подстановки Барбары Лисков\",\n  \"Interface Segregation Principle (ISP)\",\n  \"принцип разделения интерфейса\",\n  \"Dependency Inversion Principle (DIP)\",\n  \"принцип инверсии зависимостей\",\n  \"гибкий код\",\n  \"масштабируемый код\",\n  \"поддерживаемый код\",\n  \"модульность\",\n  \"наследование\",\n  \"инкапсуляция\",\n  \"абстракция\",\n  \"расширяемость\",\n  \"понимание кода\",\n  \"рефакторинг\",\n  \"архитектура программного обеспечения\",\n  \"принципы проектирования\",\n  \"классы и объекты\",\n  \"интерфейсы\",\n  \"зависимости между модулями\"\n]"
  },
  {
    "question": "Что делает хороший код хорошим?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Читаемость: Хороший код легко читается и понимается другими разработчиками. Он использует понятные и описательные имена переменных, функций и классов, а также имеет хорошую структуру и форматирование.\nПонятность: Хороший код ясно выражает свою цель и намерения. Он должен быть простым, без излишних усложнений, и каждая его часть должна иметь свою определенную задачу.\nЭффективность: Хороший код оптимизирован и эффективен в использовании ресурсов. Он не содержит лишних вычислений или операций, и обладает хорошей производительностью.\nМасштабируемость: Хороший код спроектирован с учетом будущего расширения и масштабирования. Он легко адаптируется к изменениям требований и росту проекта.\nПоддерживаемость: Хороший код удобен для поддержки и обновлений. Он разделен на модули, имеет хорошую документацию, комментарии и следует принципам хорошего программирования.\nНадежность: Хороший код минимизирует возможность ошибок и багов. Он проверяет входные данные на корректность, обрабатывает ошибки и предотвращает сбои.\nТестируемость: Хороший код легко поддается автоматизированному тестированию. Он имеет хорошо структурированные модули и четкие интерфейсы, что упрощает написание тестов.\nБезопасность: Хороший код обеспечивает безопасность данных и защиту от возможных атак, таких как инъекции и переполнение буфера.\nПравильное использование ресурсов: Хороший код управляет ресурсами (памятью, файлами, сетью) должным образом и предотвращает утечки ресурсов.\nСоблюдение стандартов: Хороший код следует установленным стандартам кодирования и принятым правилам стиля в рамках проекта или команды разработчиков.",
    "code_snippet": "",
    "key_terms": "[\n  \"читаемость\",\n  \"понятность\",\n  \"эффективность\",\n  \"масштабируемость\",\n  \"поддерживаемость\",\n  \"надежность\",\n  \"тестируемость\",\n  \"безопасность\",\n  \"управление ресурсами\",\n  \"соблюдение стандартов\",\n  \"описательные имена\",\n  \"структура кода\",\n  \"форматирование\",\n  \"простота\",\n  \"оптимизация\",\n  \"адаптивность\",\n  \"модульность\",\n  \"документация\",\n  \"обработка ошибок\",\n  \"автоматизированное тестирование\",\n  \"защита данных\",\n  \"предотвращение багов\",\n  \"управление памятью\",\n  \"стиль кодирования\",\n  \"комментарии\",\n  \"чистый код\",\n  \"архитектура\",\n  \"рефакторинг\",\n  \"командная разработка\"\n]"
  },
  {
    "question": "Что такое CORS?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "CORS (Cross-Origin Resource Sharing) - это механизм безопасности, используемый в веб-разработке для контроля доступа к ресурсам на веб-странице, размещенным на другом домене (origin). \"Origin\" - это комбинация протокола (например, http или https), домена и порта веб- страницы.\n\nБраузеры применяют политику CORS для защиты веб-приложений от несанкционированных запросов к ресурсам на других доменах, что называется \"Cross-Origin Request\" (CORS запрос). По умолчанию, из-за политики безопасности браузера, JavaScript-код, выполняемый на веб-странице, имеет доступ только к ресурсам, находящимся на том же домене, с которого была загружена страница.\nОднако с помощью заголовков CORS на сервере, можно разрешить браузеру выполнять CORS запросы и получать доступ к ресурсам на других доменах. Это делает возможным безопасное взаимодействие между веб-приложениями, размещенными на разных доменах.\nКогда браузер делает запрос на другой домен, он сначала отправляет предварительный запрос (preflight request) методом OPTIONS, чтобы проверить, разрешен ли запрос. Сервер должен ответить с заголовками CORS, указывающими, разрешено ли выполнять запросы с данного домена.\n\nCORS является важным аспектом безопасности веб-приложений и позволяет предотвратить различные типы атак, таких как CSRF (Cross-Site Request Forgery) и XSS (Cross-Site Scripting).",
    "code_snippet": "",
    "key_terms": "[\n  \"CORS\",\n  \"Cross-Origin Resource Sharing\",\n  \"механизм безопасности\",\n  \"веб-разработка\",\n  \"контроль доступа\",\n  \"ресурсы на другом домене\",\n  \"origin\",\n  \"протокол\",\n  \"домен\",\n  \"порт\",\n  \"политика одного источника\",\n  \"same-origin policy\",\n  \"кросс-доменные запросы\",\n  \"браузер\",\n  \"JavaScript\",\n  \"предварительный запрос\",\n  \"preflight request\",\n  \"HTTP метод OPTIONS\",\n  \"заголовки CORS\",\n  \"Access-Control-Allow-Origin\",\n  \"разрешение доступа\",\n  \"безопасное взаимодействие\",\n  \"защита от CSRF\",\n  \"защита от XSS\",\n  \"сервер\",\n  \"клиент\",\n  \"HTTP-запросы\",\n  \"междоменные атаки\",\n  \"политика безопасности браузера\",\n  \"контроль доступа к ресурсам\"\n]"
  },
  {
    "question": "О каких уязвимостях знаешь или слышал?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "Существует множество различных уязвимостей, которые могут быть использованы злоумышленниками для нанесения вреда пользователям или системам.\n1. SQL-инъекции (SQL Injection): Происходят, когда злоумышленник может внедрить или \"инъецировать\" вредоносный SQL-код в запрос, который изменяет стандартное выполнение запроса к базе данных. Это может привести к несанкционированному доступу к данным, их изменению или удалению.\n2. Cross-Site Scripting (XSS): Позволяет злоумышленникам внедрять клиентский скрипт в веб-страницы, просматриваемые другими пользователями. Это может привести к краже cookie-файлов, сессий, персональных данных и других атак на клиентскую сторону.\n3. Cross-Site Request Forgery (CSRF): Заставляет пользователя выполнить нежелательные действия на веб-сайте, на котором он в настоящее время аутентифицирован, например, отправить запрос на смену пароля или выполнить платеж от имени пользователя.\n4. Разглашение информации: Происходит, когда веб-приложение раскрывает чувствительную информацию, такую как технические детали своей работы, структуры баз данных или креденциалы, что может быть использовано злоумышленниками.\n5. Небезопасная десериализация: Это уязвимость, при которой недостаточно проверенные или небезопасные данные могут быть десериализованы и выполнены как код, что может привести к удаленному выполнению кода, внедрению вредоносных скриптов или атакам отказа в обслуживании.\n6. Использование компонентов с известными уязвимостями: Включает использование сторонних библиотек и зависимостей, которые содержат известные уязвимости. Это может подвергнуть приложение риску атак.\n7. Недостатки в управлении сессиями: Уязвимости, связанные с управлением сессиями и аутентификацией, могут позволить злоумышленникам перехватывать или подделывать сессии пользователей, получать несанкционированный доступ к учетным записям.\n8. Security Misconfiguration (Неправильная настройка безопасности): Это самый широкий класс уязвимостей, который включает в себя неправильно настроенные разрешения, стандартные учетные записи с известными паролями, открытые облачные хранилища и другие ошибки в конфигурации.\n9. Недостатки в контроле доступа: Происходят, когда пользователи могут получить доступ к функциям или данным, к которым у них не должно быть доступа. Это может включать доступ к данным других пользователей, выполнение функций администратора и т.д.\n10. Внедрение вредоносного кода (Malware Upload): Уязвимости, позволяющие злоумышленникам загружать и выполнять вредоносный код на сервере или у клиентов.\nДля защиты от этих и других уязвимостей нужно следовать лучшим практикам безопасности, регулярно обновлять используемое программное обеспечение, проводить аудиты безопасности и использовать инструменты для сканирования уязвимостей.",
    "code_snippet": "",
    "key_terms": "[\n  \"SQL-инъекция\",\n  \"SQL Injection\",\n  \"внедрение вредоносного SQL-кода\",\n  \"несанкционированный доступ к данным\",\n  \"изменение и удаление данных\",\n  \"Cross-Site Scripting\",\n  \"XSS\",\n  \"внедрение клиентских скриптов\",\n  \"кража cookie и сессий\",\n  \"перенаправление пользователей\",\n  \"Cross-Site Request Forgery\",\n  \"CSRF\",\n  \"межсайтовая подделка запроса\",\n  \"нежелательные действия от имени пользователя\",\n  \"разглашение информации\",\n  \"утечка технических данных\",\n  \"небезопасная десериализация\",\n  \"удаленное выполнение кода\",\n  \"использование уязвимых компонентов\",\n  \"уязвимости сторонних библиотек\",\n  \"управление сессиями\",\n  \"перехват и подделка сессий\",\n  \"неправильная настройка безопасности\",\n  \"Security Misconfiguration\",\n  \"недостатки контроля доступа\",\n  \"несанкционированный доступ к функциям\",\n  \"внедрение вредоносного кода\",\n  \"Malware Upload\",\n  \"Clickjacking\",\n  \"SSRF (Server-Side Request Forgery)\",\n  \"LFI/RFI (Local/Remote File Inclusion)\",\n  \"атаки на пользователей\",\n  \"уязвимости веб-приложений\",\n  \"нарушение аутентификации\",\n  \"ошибки логирования и мониторинга\",\n  \"ошибки идентификации\",\n  \"переиспользование паролей\",\n  \"атаки на внутренние сервисы\",\n  \"компрометация данных\",\n  \"фишинг\",\n  \"вредоносные скрипты\",\n  \"недостаточная фильтрация данных\"\n]"
  },
  {
    "question": "Что такое микросервисная архитектура?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "Это особый метод разработки программных систем, который пытается сосредоточиться на создании однофункциональных модулей с четко определенными интерфейсами и операциями. Эта тенденция стала популярной в последние годы, поскольку предприятия стремятся стать более гибкими и перейти к DevOps и непрерывному тестированию.",
    "code_snippet": "",
    "key_terms": "[\n  \"микросервисная архитектура\",\n  \"MSA\",\n  \"распределённая система\",\n  \"микросервисы\",\n  \"независимые сервисы\",\n  \"однофункциональные модули\",\n  \"ограниченный контекст (Bounded Context)\",\n  \"взаимодействие по сети\",\n  \"Smart endpoints and dumb pipes\",\n  \"Design for failure\",\n  \"автоматизация разработки\",\n  \"итерационное развитие\",\n  \"контейнеризация\",\n  \"оркестрация\",\n  \"Kubernetes\",\n  \"Docker Swarm\",\n  \"балансировка нагрузки\",\n  \"отказоустойчивость\",\n  \"API\",\n  \"легковесные протоколы\",\n  \"гибкость разработки\",\n  \"масштабируемость\",\n  \"автономность сервисов\",\n  \"разделение ответственности\",\n  \"разные языки программирования\",\n  \"DevOps\",\n  \"непрерывное тестирование\",\n  \"декомпозиция приложения\",\n  \"управление сервисами\",\n  \"обновление без простоя\"\n]"
  },
  {
    "question": "Что такое ORM?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "ORM (Object-Relational Mapping, объектно-реляционное отображение) — это техника, используемая для преобразования данных между несовместимыми типами систем, в частности между объектно-ориентированными языками программирования и реляционными базами данных. ORM предоставляет абстрактный API, который позволяет вам работать с базой данных с использованием объектно-ориентированных подходов, вместо того чтобы писать SQL-запросы.\nКлючевые принципы ORM:\n1. Отображение таблиц данных на классы: В нем каждая таблица в базе данных обычно отображается на класс в программе. Это позволяет работать с записями таблицы как с объектами указанного класса.\n2. Отображение столбцов таблиц на атрибуты класса: Столбцы таблицы в базе данных отображаются на атрибуты класса, что позволяет обращаться к данным записи прямо через свойства объекта.\n3. Управление связями между данными: Автоматически управляет отношениями между данными, такими как один-ко-многим, многие-ко-многим, позволяя разработчикам легко настраивать и использовать связанные данные.\n4. Автоматизация запросов к базе данных: Позволяет выполнять запросы к базе данных, используя методы и функции высокого уровня, автоматически преобразуя их в SQL-запросы и обратно, что сокращает необходимость в ручной работе с SQL.\n\nПреимущества использования:\nПродуктивность разработки: Можно сосредоточиться на логике приложения, а не на деталях реализации базы данных.\nУменьшение количества кода: Генерирует многие стандартные SQL-запросы автоматически, что уменьшает количество необходимого для написания кода.\nБезопасность: Большинство таких фреймворков автоматически обрабатывают проблемы безопасности, такие как SQL-инъекции.\nПереносимость: Запросы, сгенерированные им, могут быть независимы от конкретной СУБД, что упрощает миграцию между разными базами данных.\n\nНедостатки:\nСложность: Может добавить сложность в проект, особенно в случаях, когда требуется настройка производительности или обработка сложных запросов.\nПроизводительность: В некоторых случаях автоматически генерируемые запросы могут быть менее оптимизированы, чем ручно написанные SQL-запросы.\n\nПримеры популярных ORM фреймворков включают Hibernate, JPA (Java Persistence API), MyBatis и другие. Они обеспечивают разработчикам инструменты для эффективной работы с базой данных в объектно-ориентированном стиле.",
    "code_snippet": "",
    "key_terms": "[\n  \"ORM\",\n  \"Object-Relational Mapping\",\n  \"объектно-реляционное отображение\",\n  \"технология программирования\",\n  \"преобразование данных\",\n  \"объектно-ориентированное программирование\",\n  \"реляционные базы данных\",\n  \"виртуальная объектная база данных\",\n  \"отображение таблиц на классы\",\n  \"отображение столбцов на атрибуты\",\n  \"управление связями между данными\",\n  \"автоматизация SQL-запросов\",\n  \"CRUD-операции\",\n  \"создание, чтение, обновление, удаление\",\n  \"абстрактный API\",\n  \"снижение необходимости писать SQL\",\n  \"повышение продуктивности разработки\",\n  \"уменьшение количества кода\",\n  \"безопасность (защита от SQL-инъекций)\",\n  \"переносимость между СУБД\",\n  \"сложность настройки\",\n  \"потенциальные проблемы с производительностью\",\n  \"Hibernate\",\n  \"JPA\",\n  \"MyBatis\",\n  \"Session\",\n  \"связи один-ко-многим, многие-ко-многим\",\n  \"автоматическое преобразование объектов в записи\",\n  \"интеграция с языками программирования\",\n  \"повышение уровня абстракции\",\n  \"упрощение работы с базой данных\"\n]"
  },
  {
    "question": "Что такое REST?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "REST (Representational State Transfer — «передача репрезентативного состояния»)\nREST — это набор правил того, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать\nОпределяет определенные стандарты, которым веб-сервисы должны соответствовать, чтобы считаться RESTful. Эти рекомендации гарантируют быструю и эффективную передачу запросов и ресурсов между клиентом и сервером с использованием стандартизированных протоколов HTTP.",
    "code_snippet": "",
    "key_terms": "[\n  \"REST\",\n  \"Representational State Transfer\",\n  \"архитектурный стиль\",\n  \"веб-сервисы\",\n  \"клиент-серверная модель\",\n  \"stateless\",\n  \"отсутствие состояния\",\n  \"кэширование\",\n  \"единый интерфейс\",\n  \"многоуровневая архитектура\",\n  \"код по требованию\",\n  \"масштабируемость\",\n  \"высокая производительность\",\n  \"адаптивность\",\n  \"портативность\",\n  \"отказоустойчивость\",\n  \"протокол HTTP\",\n  \"форматы JSON и XML\",\n  \"HTTP методы (GET, POST, PUT, DELETE)\",\n  \"идемпотентность\",\n  \"URL как идентификатор ресурса\",\n  \"RESTful сервисы\",\n  \"API Blueprint\",\n  \"Swagger\",\n  \"тестирование REST API\",\n  \"TLS/SSL\",\n  \"безопасная передача данных\",\n  \"унифицированный интерфейс\",\n  \"разделение клиента и сервера\",\n  \"архитектура распределённых систем\",\n  \"принципы REST\"\n]"
  },
  {
    "question": "Что такое ACID?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "В информатике акроним ACID описывает требования к транзакционной системе (например, к СУБД), обеспечивающие наиболее надёжную и предсказуемую её работу.\n\nA - Atomicity. Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние — со стороны будет казаться, что транзакции и не было. (Естественно, счётчики, индексы и другие внутренние структуры могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.)\nC - Consistency — Согласованность. Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвёртого свойства.\n\nСогласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисления, то система останется в некорректном состоянии и свойство согласованности будет нарушено.\nНаконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего, двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.\n\nI - Isolation — Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию. Уровни изоляции транзакций\nD - Durability — Стойкость. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.",
    "code_snippet": "",
    "key_terms": "[\n  \"ACID\",\n  \"атомарность\",\n  \"atomicity\",\n  \"согласованность\",\n  \"consistency\",\n  \"изолированность\",\n  \"isolation\",\n  \"стойкость\",\n  \"durability\",\n  \"транзакционная система\",\n  \"СУБД\",\n  \"транзакция\",\n  \"откат транзакции\",\n  \"rollback\",\n  \"консистентность данных\",\n  \"параллельные транзакции\",\n  \"устойчивость к сбоям\",\n  \"фиксация транзакции\",\n  \"база данных\",\n  \"надежность\",\n  \"целостность данных\",\n  \"управление транзакциями\",\n  \"уровни изоляции\",\n  \"транзакционные свойства\"\n]"
  },
  {
    "question": "Что такое кэширование?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Кэширование - это техника, используемая в программировании, которая заключается в сохранении временный копий данных, результатов\nвычислений или ресурсов в более быстром доступе, чтобы улучшить производительность и сократить нагрузку на систему.\n\nОднако кэширование также имеет свои ограничения и недостатки:\n- Занимаемое место: кэш занимает дополнительное место в памяти или на диске.\n- Согласованность данных: Если данные обновляются в источнике, необходимо правильно обрабатывать синхронизацию и инвалидацию кэша, чтобы\nпредотвратить предоставление устаревших данных",
    "code_snippet": "",
    "key_terms": "[\n  \"кэширование\",\n  \"cache\",\n  \"временное хранение данных\",\n  \"быстрый доступ\",\n  \"оптимизация производительности\",\n  \"снижение нагрузки на систему\",\n  \"оперативная память (RAM)\",\n  \"хэш-таблица\",\n  \"время жизни данных (TTL)\",\n  \"инвалидация кэша\",\n  \"согласованность данных\",\n  \"буферизация\",\n  \"программный кэш\",\n  \"аппаратный кэш\",\n  \"повторное использование данных\",\n  \"ускорение извлечения данных\",\n  \"кэш браузера\",\n  \"кэш базы данных\",\n  \"кэширование на уровне приложений\",\n  \"риски устаревших данных\"\n]"
  },
  {
    "question": "Что такое TDD?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "TDD — это методика разработки приложений, при которой сначала пишется тест, покрывающий желаемое изменение, а затем — код, который позволит пройти тест.",
    "code_snippet": "",
    "key_terms": "[\n  \"TDD\",\n  \"Test Driven Development\",\n  \"разработка через тестирование\",\n  \"короткие циклы разработки\",\n  \"написание теста перед кодом\",\n  \"покрытие изменений тестами\",\n  \"написание кода для прохождения теста\",\n  \"рефакторинг кода\",\n  \"красный-зеленый-рефактор\",\n  \"автоматизированное тестирование\",\n  \"повышение качества кода\",\n  \"минимальный код\",\n  \"проверка работоспособности\",\n  \"уверенность в коде\",\n  \"цикл разработки\",\n  \"модульное тестирование\",\n  \"поведение системы\",\n  \"JIT (just-in-time) требования\",\n  \"ATDD\",\n  \"BDD\",\n  \"DevOps\",\n  \"интеграция тестирования в процесс разработки\"\n]"
  },
  {
    "question": "Что такое монолит?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений.",
    "code_snippet": "",
    "key_terms": "[\n  \"монолит\",\n  \"монолитная архитектура\",\n  \"единый модуль\",\n  \"автономное приложение\",\n  \"единая кодовая база\",\n  \"тесная связь компонентов\",\n  \"веб-приложения\",\n  \"бизнес-логика\",\n  \"база данных\",\n  \"развертывание\",\n  \"масштабирование\",\n  \"сложность изменений\",\n  \"производительность\",\n  \"простота разработки\",\n  \"тестирование\",\n  \"поддержка\",\n  \"обновление\",\n  \"архитектурные подходы\",\n  \"стартапы\","
  },
  {
    "question": "Что такое CI CD?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "High",
    "reference_answer": "Непрерывная интеграция — это методология разработки и набор практик, при которых в код вносятся небольшие изменения с частыми коммитами. И поскольку большинство современных приложений разрабатываются с использованием различных платформ и инструментов, то появляется необходимость в механизме интеграции и тестировании вносимых изменений.\nС технической точки зрения, цель CI — обеспечить последовательный и автоматизированный способ сборки, упаковки и тестирования приложений. При налаженном процессе непрерывной интеграции разработчики с большей вероятностью будут делать частые коммиты, что, в свою очередь, будет способствовать улучшению коммуникации и повышению качества программного обеспечения.\nНепрерывная поставка начинается там, где заканчивается непрерывная интеграция. Она автоматизирует развертывание приложений в различные окружения: большинство разработчиков работают как с продакшн-окружением, так и со средами разработки и тестирования.\nИнструменты CI/CD помогают настраивать специфические параметры окружения, которые конфигурируются при развертывании. А также CI/CD-автоматизация выполняет необходимые запросы к веб-серверам, базам данных и другим сервисам, которые могут нуждаться в перезапуске или выполнении каких-то дополнительных действий при развертывании приложения.\nНепрерывная интеграция и непрерывная поставка нуждаются в непрерывном тестировании, поскольку конечная цель — разработка качественных приложений. Непрерывное тестирование часто реализуется в виде набора различных автоматизированных тестов (регрессионных, производительности и других), которые выполняются в CI/CD-конвейере.\nЗрелая практика CI/CD позволяет реализовать непрерывное развертывание: при успешном прохождении кода через CI/CD-конвейер, сборки автоматически развертываются в продакшн-окружении. Команды, практикующие непрерывную поставку, могут позволить себе ежедневное или даже ежечасное развертывание. Хотя здесь стоит отметить, что непрерывная поставка подходит не для всех бизнес-приложений.",
    "code_snippet": "",
    "key_terms": "[\n  \"CI\",\n  \"Continuous Integration\",\n  \"непрерывная интеграция\",\n  \"частые коммиты\",\n  \"автоматизированная сборка\",\n  \"автоматическое тестирование\",\n  \"улучшение качества кода\",\n  \"коммуникация в команде\",\n  \"CD\",\n  \"Continuous Delivery\",\n  \"непрерывная поставка\",\n  \"автоматическое развертывание\",\n  \"тестовые и продакшн окружения\",\n  \"конфигурация окружения\",\n  \"автоматизация развертывания\",\n  \"непрерывное тестирование\",\n  \"регрессионные тесты\",\n  \"производительность\",\n  \"непрерывное развертывание\",\n  \"DevOps\",\n  \"автоматизация жизненного цикла разработки\",\n  \"конвейер CI/CD\",\n  \"ускорение выпуска продукта\",\n  \"качество программного обеспечения\",\n  \"инструменты CI/CD\"\n]"
  },
  {
    "question": "Оцени сложность алгоритмов\n\n1) for i in n:\n    something\n\n2) \nfor i in n:\n    something\nfor j in n:\n    something\n\n3) for i in n:\n       for j in i:\n        something",
    "category": "Python",
    "question_type": "case",
    "difficulty": "Medium",
    "reference_answer": "1) O(n)\n2) O(n)\n3) O(n*i)",
    "code_snippet": "",
    "key_terms": "[\n  \"сложность алгоритма\",\n  \"Big O\",\n  \"O(n)\",\n  \"O(n*i)\",\n  \"линейная сложность\",\n  \"вложенные циклы\",\n  \"итерация по списку\",\n  \"оценка производительности\",\n  \"худший случай\",\n  \"асимптотическая сложность\",\n  \"Python\",\n  \"анализ алгоритмов\",\n  \"циклы for\",]"
  },
  {
    "question": "В чем отличие list от tuple?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "list - изменяемый тип данных",
    "code_snippet": "",
    "key_terms": "[\n  \"list\",\n  \"tuple\",\n  \"изменяемость\",\n  \"неизменяемость\",\n  \"мутабельность\",\n  \"иммутабельность\",\n  \"Python\",\n  \"последовательности\",\n  \"изменение элементов\",\n  \"операции с элементами\",\n  \"использование памяти\",\n  \"скорость доступа\",\n  \"создание\",\n  \"функциональные отличия\",\n  \"применение\"\n]"
  },
  {
    "question": "Что такое List Comprehension?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "List comprehension в Python - это синтаксическая конструкция, которая позволяет создавать новый список на основе элементов существующего списка или другого итерируемого объекта с использованием более компактного и выразительного синтаксиса.\n\nВ общем виде, синтаксис list comprehension выглядит следующим образом:\nnew_list = [expression for item in iterable if condition] где:\nexpression - это выражение, которое применяется к каждому элементу входного списка (iterable), чтобы создать соответствующий элемент в выходном списке (new_list).\nitem - это переменная, которая принимает каждый элемент входного списка (iterable).\niterable - это исходный список, из которого нужно извлечь элементы для нового списка.\ncondition (не обязательно) - это условие, которое должно быть истинным для каждого элемента входного списка (iterable), чтобы он был включен в выходной список (new_list).",
    "code_snippet": "",
    "key_terms": "[\n  \"List Comprehension\",\n  \"Python\",\n  \"создание списков\",\n  \"синтаксический сахар\",\n  \"итерируемые объекты\",\n  \"expression\",\n  \"item\",\n  \"iterable\",\n  \"condition\",\n  \"фильтрация элементов\",\n  \"генерация списков\",\n  \"компактный код\",\n  \"выражения в списках\",\n  \"альтернатива циклам\",\n  \"читаемость кода\"\n]"
  },
  {
    "question": "Как удалить начальный пробел в строке?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Для удаления начального пробела в строке в Python можно использовать метод lstrip(). Например:\nmy_string = \"   example string\"\nmy_string = my_string.lstrip()\nprint(my_string)\nЭтот код выведет строку без начального пробела: \"example string\".",
    "code_snippet": "",
    "key_terms": "[\n  \"удаление пробелов\",\n  \"начальные пробелы\",\n  \"строка\",\n  \"lstrip()\",\n  \"Python\",\n  \"методы строк\",\n  \"обработка текста\",\n  \"очистка данных\",\n  \"форматирование строк\",\n  \"пробелы\",\n  \"функция lstrip\",\n  \"изменение строки\",\n  \"примеры кода\",\n  \"вывод строки\",\n  \"работа с текстом\"\n]"
  },
  {
    "question": "Напишите функцию Python, которая проверяет, является ли переданная строка палиндромом или нет?",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Easy",
    "reference_answer": "def is_palindrome(s):\n    return s == s[::-1]\n\nЭта функция использует срезы для создания обратной копии строки и затем сравнивает ее с оригинальной строкой. Если строки равны друг другу, то переданная строка является палиндромом.",
    "code_snippet": "def is_palindrome(s):\n    return s == s[::-1]",
    "key_terms": "[\n  \"функция\",\n  \"Python\",\n  \"проверка палиндрома\",\n  \"строка\",\n  \"срезы\",\n  \"реверс строки\",\n  \"логическое выражение\",\n  \"возврат значения\",\n  \"is_palindrome\",\n  \"обработка строк\",\n  \"симметрия\",\n  \"условие\",\n  \"булев тип\",\n  \"простая функция\",\n  \"эффективность\"\n]"
  },
  {
    "question": "Что такое итератор?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Итератор — это объект, который позволяет обойти все элементы коллекции (список, кортеж, словарь и т.д.). Итераторы создаются с помощью двух методов: `__iter__()` и `__next__()`.",
    "code_snippet": "",
    "key_terms": "[\n  \"итератор\",\n  \"__iter__\",\n  \"__next__\",\n  \"протокол итератора\",\n  \"StopIteration\",\n  \"итерируемый объект\",\n  \"перебор элементов\",\n  \"последовательность\",\n  \"обход коллекции\",\n  \"функция iter()\",\n  \"функция next()\",\n  \"Python\",\n  \"цикл for\",\n  \"обработка исключений\",\n  \"ленивая итерация\"\n]"
  },
  {
    "question": "Что такое *args и **kwargs в определении функции def f(*args, **kwargs)",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Это специальные параметры, в которые можно положить переменное количество объектов. \n*args отвечает за переменные без ключевого слова, а **kwargs отвечает за именнованные переменные",
    "code_snippet": "",
    "key_terms": "[\n  \"*args\",\n  \"**kwargs\",\n  \"переменное количество аргументов\",\n  \"позиционные аргументы\",\n  \"именованные аргументы\",\n  \"кортеж\",\n  \"словарь\",\n  \"распаковка аргументов\",\n  \"Python\",\n  \"функции\",\n  \"синтаксис * и **\",\n  \"универсальные параметры\",\n  \"передача аргументов\",\n  \"гибкость функций\",\n  \"соглашения по именованию\"\n]"
  },
  {
    "question": "Объясните, что выведет следующий код\n\n1) b = [i for i in range(10)]\n2) b = (i for i in range(10))\n3) b = {i for i in range(10)}\n4) b = {x: x**2 for x in range(10)}",
    "category": "Python",
    "question_type": "case",
    "difficulty": "Medium",
    "reference_answer": "1) Создание списка от 0 до 9\n2) Создание генераторного выражения\n3) Создание сета от 0 до 9\n4) Создание словаря, ключи в котором - числа от 0 до 9, а значения - квадраты ключей",
    "code_snippet": "",
    "key_terms": "[\n  \"list comprehension\",\n  \"генераторное выражение\",\n  \"set comprehension\",\n  \"dict comprehension\",\n  \"range\",\n  \"Python\",\n  \"создание коллекций\",\n  \"итерируемые объекты\",\n  \"выражения генераторов\",\n  \"множества\",\n  \"словари\",\n  \"ключи и значения\",\n  \"квадраты чисел\",\n  \"перебор элементов\",\n  \"типы данных\"\n]"
  },
  {
    "question": "Что такое контекстный менеджер",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Это любой объект у которого определены методы __enter__ __exit__\nОн нужен, например, для открытия и закрытия соединения с бд/фалом.",
    "code_snippet": "",
    "key_terms": "[\n  \"контекстный менеджер\",\n  \"__enter__\",\n  \"__exit__\",\n  \"оператор with\",\n  \"управление ресурсами\",\n  \"автоматическое закрытие\",\n  \"обработка исключений\",\n  \"Python\",\n  \"освобождение ресурсов\",\n  \"инициализация и финализация\",\n  \"протокол контекстного менеджера\",\n  \"создание собственного контекстного менеджера\",\n  \"contextlib.contextmanager\",\n  \"асинхронный контекстный менеджер\",\n  \"блок try...finally\"\n]"
  },
  {
    "question": "Как dict и set реализованы внутри? Какова сложность получения элемента? Сколько памяти потребляет каждая структура?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Dict и Set реализованы в виде хэш-таблицы.\n\nХэш-таблица - это структура данных, которая использует хэш-функцию для преобразования ключа в индекс в массиве, где хранятся значения. Затем элемент добавляется в массив по соответствующему индексу.\n\nСложность получения элемента в Dict и Set в наилучшем случае составляет O(1), поскольку элемент может быть получен просто с помощью хэш-функции в качестве индекса массива. Однако в худшем случае, когда возникают хэш-коллизии, сложность может вырасти до O(n), где n - количество элементов в таблице.\n\nТакже стоит заметить, что сложность операций добавления, удаления и поиска элементов в Set и Dict также составляет O(1) в наилучшем случае и O(n) в худшем случае.",
    "code_snippet": "",
    "key_terms": "[\n  \"dict\",\n  \"set\",\n  \"Хэш-таблица\",\n  \"Хэш-функция\",\n  \"Buckets\",\n  \"Коллизии\",\n  \"Открытая адресация\",\n  \"Цепочки\",\n  \"Сложность доступа O(1)\",\n  \"Худший случай O(n)\",\n  \"Выделение памяти\",\n  \"64-битный процессор\",\n  \"Указатель на объект\",\n  \"Оптимизация памяти\",\n  \"Python\",\n  \"Внутреннее устройство\",\n  \"Поиск элемента\",\n  \"Добавление элемента\",\n  \"Удаление элемента\",\n  \"Компактный dict\",\n  \"Индексы и записи\",\n  \"Упорядоченность ключей\",\n  \"Изоляция ключей и значений\",\n  \"Размер хэш-таблицы\",\n  \"Расширение таблицы\"\n]"
  },
  {
    "question": "Как посмотреть методы объекта?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "print(dir(obj))",
    "code_snippet": "",
    "key_terms": "[\n  \"методы объекта\",\n  \"dir()\",\n  \"Python\",\n  \"инспекция объектов\",\n  \"атрибуты объекта\",\n  \"встроенные функции\",\n  \"отладка\",\n  \"рефлексия\",\n  \"список методов\",\n  \"объектно-ориентированное программирование\",\n  \"интерактивная работа с объектами\",\n  \"print\",\n  \"вывод информации\",\n  \"разработка\",\n  \"исследование кода\"\n]"
  },
  {
    "question": "Объясните тернарный оператор в Python?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "В Python тернарный оператор используется для написания простых конструкций if-else в одну строку. \nОн имеет следующий синтаксис:\nvalue_if_true if condition else value_if_false",
    "code_snippet": "",
    "key_terms": "[\n  \"тернарный оператор\",\n  \"условное выражение\",\n  \"синтаксис\",\n  \"value_if_true\",\n  \"condition\",\n  \"value_if_false\",\n  \"if-else в одну строку\",\n  \"Python\",\n  \"компактный код\",\n  \"вложенные тернарные операторы\",\n  \"генераторы\",\n  \"списковые включения\",\n  \"приоритет операторов\",\n  \"альтернативные конструкции\",\n  \"читаемость кода\"\n]"
  },
  {
    "question": "Что такое функции высшего порядка?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Функции высшего порядка - это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции в качестве результата. Это является важным концептом в функциональном программировании и может упростить написание кода, делая его более элегантным и модульным.\n\nВ Python встроены несколько функций высшего порядка, таких как map(), filter() и reduce().\n\nФункция map() применяет заданную функцию к каждому элементу итерируемого объекта и возвращает итератор с результатами.\n\nФункция filter() применяет заданную функцию к каждому элементу итерируемого объекта и возвращает итератор с элементами, для которых функция вернула True.\n\nФункция reduce() объединяет элементы итерируемого объекта в одно значение, используя заданную функцию.",
    "code_snippet": "",
    "key_terms": "[\n  \"Функции высшего порядка\",\n  \"Python\",\n  \"Функции первого порядка\",\n  \"Прием функций в аргументах\",\n  \"Возврат функций\",\n  \"map\",\n  \"filter\",\n  \"reduce\",\n  \"Функциональное программирование\",\n  \"Модульный код\",\n  \"Анонимные функции\",\n  \"lambda\",\n  \"Композиция функций\",\n  \"Повторное использование кода\",\n  \"Итераторы\"\n]"
  },
  {
    "question": "Разница между append и extend для списков?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "1. append() принимает один аргумент item и добавляет его в конец list. Тип параметра может быть любым: числа, строки, словари и так далее. Метод возвращает объект None — то есть ничего.\n2. extend() добавляет новые элементы в конец списка, но, в отличие от append(), принимает в качестве параметров итерируемые объекты: списки, кортежи и строки. При этом объединяемые списки могут содержать элементы любых типов: например, вы можете объединить строки с числами или числа с кортежами. \nОбратите внимание: строки, которые передаются в extend(), превращаются в списки символов и добавляются посимвольно. Так, строка 'man' разложилась на 'm', 'a', 'n'.",
    "code_snippet": "",
    "key_terms": "[\n  \"append\",\n  \"extend\",\n  \"Списки Python\",\n  \"Методы списков\",\n  \"Добавление элементов\",\n  \"Итерируемые объекты\",\n  \"Типы данных\",\n  \"Изменяемые объекты\",\n  \"Объединение списков\",\n  \"Поведение со строками\",\n  \"Разница append и extend\",\n  \"Модификация списка\",\n  \"Python методы\",\n  \"Последовательности\",\n  \"Коллекции данных\"\n]"
  },
  {
    "question": "Для чего нужны генераторы и итераторы?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "В общем, итераторы и генераторы обеспечивают удобный способ работы с коллекциями данных в Python. Они позволяют перебирать элементы коллекций, не загружая все элементы в память одновременно, что делает их очень эффективными для работы с большими наборами данных.",
    "code_snippet": "",
    "key_terms": "[\n  \"Итераторы\",\n  \"Генераторы\",\n  \"Python\",\n  \"Ленивая загрузка\",\n  \"Обход коллекций\",\n  \"Память\",\n  \"Ключевое слово yield\",\n  \"Протокол итератора\",\n  \"__iter__\",\n  \"__next__\",\n  \"Объекты-генераторы\",\n  \"Эффективность\",\n  \"Последовательный перебор\",\n  \"Генераторные функции\",\n  \"Одноразовое использование генераторов\"\n]"
  },
  {
    "question": "Расположите функции в порядке эффективности, объясните выбор.\n\ndef f1(arr):\n   l1 = sorted(arr)\n   l2 = [i for i in l1 if i < 5]\n   return [i * i for i in l2]\n\ndef f2(arr):\n   l1 = [i for i in arr if i < 5]\n   l2 = sorted(l1)\n   return [i * i for i in l2]\n\ndef f3(arr):\n   l1 = [i * i for i in arr]\n   l2 = sorted(l1)\n   return [i for i in l1 if i < (5 * 5)]",
    "category": "Python",
    "question_type": "case",
    "difficulty": "Medium",
    "reference_answer": "Наиболее эффективной функцией из трех предоставленных, вероятно, будет f2. Это связано с тем, что он избегает сортировки всего списка, вместо этого сортируется только меньший предварительно отфильтрованный список. Вот почему:\n\nf1 сортирует весь список с помощью функции sorted, которая имеет временную сложность O(n log n), где n — длина входного списка. После сортировки он отфильтровывает все элементы, большие или равные 5, и вычисляет квадраты оставшихся элементов. Фильтрация списка занимает время O(n), а окончательное вычисление занимает время O(m), где m — длина отфильтрованного списка. Следовательно, общая временная сложность этой функции равна O(n log n + n + m).\n\nf2 сначала фильтрует входной список, чтобы включить только элементы меньше 5, что занимает O(n) времени. Затем он сортирует этот отфильтрованный список с помощью функции sorted, которая имеет временную сложность O(m log m), где m — длина отфильтрованного списка. Наконец, он вычисляет квадраты отсортированных элементов. Вычисление квадратов занимает O(m) времени. Поэтому, общая временная сложность этой функции составляет O (n + m log m + m).\n\nf3 вычисляет квадраты всех элементов во входном списке, что занимает O(n) времени. Затем он сортирует список в квадрате с помощью функции sorted, которая имеет временную сложность O(n log n). Наконец, он отфильтровывает все элементы меньше 25, что занимает время O(n). Таким образом, общая временная сложность этой функции равна O(n log n).\n\nТаким образом, f2 имеет наилучшую временную сложность, поскольку сортирует наименьший список, который является только отфильтрованным. Имейте в виду, что это может быть несущественным в небольших списках, и всегда ключевым фактором является бенчмаркинг.",
    "code_snippet": "",
    "key_terms": "[\n  \"Эффективность функций\",\n  \"Временная сложность\",\n  \"Сортировка\",\n  \"Фильтрация\",\n  \"Сложность O(n log n)\",\n  \"Сложность O(n)\",\n  \"Оптимизация кода\",\n  \"Python\",\n  \"Обработка списков\",\n  \"Алгоритмы сортировки\",\n  \"Сравнение алгоритмов\",\n  \"Бенчмаркинг\",\n  \"Профилирование производительности\",\n  \"Память и время выполнения\",\n  \"Функциональное программирование\"\n]"
  },
  {
    "question": "Чем is отличается от '=='?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "is - проверка на то, имеют ли переменные один и тот же адрес в памяти\n`==` - проверка на равенство именно значений",
    "code_snippet": "",
    "key_terms": "[\n  \"is\",\n  \"==\",\n  \"Оператор сравнения\",\n  \"Идентичность объектов\",\n  \"Равенство значений\",\n  \"Адрес в памяти\",\n  \"Сравнение объектов\",\n  \"Python\",  \"Оптимизация памяти\",\n  \"Булевы значения\",\n  \"Ссылочные типы\",\n  \"Изменяемые и неизменяемые объекты\",\n  \"Сравнение с None\"\n]"
  },
  {
    "question": "Можно ли использовать итераторы для создания генератора?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Medium",
    "reference_answer": "Да, итераторы могут быть использованы для создания генераторов. Генератор - это специальный тип итератора, который обычно создается с помощью ключевых слов yield или yield from.",
    "code_snippet": "",
    "key_terms": "[\n  \"Итераторы\",\n  \"Генераторы\",\n  \"Python\",\n  \"yield\",\n  \"yield from\",\n  \"Протокол итератора\",\n  \"__iter__\",\n  \"__next__\",\n  \"Функции-генераторы\",\n  \"Генераторные выражения\",\n  \"Ленивая загрузка\",\n  \"Последовательный обход\",\n  \"Создание итераторов\",\n  \"Асинхронные итераторы\"\n]"
  },
  {
    "question": "Что такое лямбда-функции?",
    "category": "Python",
    "question_type": "theory",
    "difficulty": "Easy",
    "reference_answer": "Лямбда-функция, также известная как анонимная функция, в программировании — это функция, которая не имеет имени. Лямбда-функции часто используются в функциональном программировании, где они могут быть переданы в качестве аргументов другим функциям или использованы для создания более коротких и читаемых выражений.\n\nВ языке Python лямбда-функция представляет собой короткую функцию, которая определяется с помощью ключевого слова lambda. Она может принимать любое количество аргументов и состоит из выражения, которое возвращает значение.",
    "code_snippet": "",
    "key_terms": "[\n  \"Лямбда-функция\",\n  \"Анонимная функция\",\n  \"lambda\",\n  \"Функции высшего порядка\",\n  \"map\",\n  \"filter\",\n  \"reduce\",\n  \"Однострочная функция\",\n  \"Python\",\n  \"Выражение\",\n  \"Аргументы функции\",\n  \"Функциональное программирование\",\n  \"Синтаксис lambda\",\n  \"Возвращаемое значение\",\n  \"Анонимные функции\"\n]"
  },
  {
    "question": "посчитать косинус между двумя разреженными векторами, каждый вектор - массив пар (индекс, значения). Два вектора заданы в таком формате, и нужно посчитать их косинус",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "",
    "code_snippet": "from math import sqrt\n\ndef cosine_similarity(vec1, vec2):\n    # Шаг 1: Преобразование списков в словари\n    dict1 = dict(vec1)\n    dict2 = dict(vec2)\n    \n    # Шаг 2: Вычисление скалярного произведения\n    common_indices = set(dict1.keys()) & set(dict2.keys())\n    dot_product = sum(dict1[i] * dict2[i] for i in common_indices)\n    \n    # Шаг 3: Вычисление норм векторов\n    norm1 = sqrt(sum(value ** 2 for value in dict1.values()))\n    norm2 = sqrt(sum(value ** 2 for value in dict2.values()))\n    \n    # Шаг 4: Вычисление косинуса\n    if norm1 == 0 or norm2 == 0:\n        return 0.0  # Если хотя бы один вектор нулевой длины, косинус равен 0\n    else:\n        return dot_product / (norm1 * norm2)\n\n# Пример использования\nvec1 = [(1, 3), (2, 4), (5, 6)]\nvec2 = [(2, 5), (3, 7), (5, 8)]\n\ncosine = cosine_similarity(vec1, vec2)\nprint(\"Cosine Similarity:\", cosine)",
    "key_terms": ""
  },
  {
    "question": "дан массив из нулей и единиц. Список (только нули и единицы). Нужно выполнить операцию удалению любого символа, а затем найти длину максимального непрерывного отрезка из единиц.\nТо есть нужно выбрать, какой символ удалить, а затем посчитать длину.",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "",
    "code_snippet": "def max_length_after_deletion(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # Переменные для отслеживания отрезков\n    left, right = 0, 0\n    max_length = 0\n    current_length = 0\n    prev_zero_idx = -1  # Индекс последнего встреченного нуля\n\n    while right < n:\n        if arr[right] == 1:\n            current_length += 1\n        else:\n            # Если встречаем ноль\n            if prev_zero_idx != -1:\n                # Обновляем максимальную длину, включая предыдущий ноль\n                max_length = max(max_length, right - left - 1)\n                # Смещаем левый указатель вправо за последний ноль\n                left = prev_zero_idx + 1\n            \n            prev_zero_idx = right\n            current_length = right - left\n\n        right += 1\n\n    # Обновляем максимальную длину для последнего отрезка\n    max_length = max(max_length, right - left - 1)\n\n    return max_length\n\n# Пример использования\narr = [1, 1, 0, 1, 1, 1, 0, 1, 1]\nprint(max_length_after_deletion(arr))  # Ожидаемый результат: 5",
    "key_terms": ""
  },
  {
    "question": "Дан произвольный массив целых чисел ненулевой длины. Найти монотонный подмассив максимальной длины и вернуть индексы левого и правого концов подмассива. Если таких несколько, можно вернуть любой. \n\nПримеры: [2, 7, 5, 4, 4, 3] → {0, 3}\n\n[1, 1] → {0,0} или {1,1}",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "Мое решение: завести l=0, r=1, cnt=0, res=[0,0] (cnt-переменная, указывающая на то, возрастающий или убывающий массив мы рассматриваем). Затем нужно проверять убывающий у нас массив или возрастающий, когда l-r==1, чтобы менять cnt. Дальше, если cnt == 0 и новый элемент не является частью возрастающего подмассива, если длина подмассива больше, чем длина того, который в рез - обновляем, ставим l = r - 1, r = r - 1, если у нас r≠r-1 (иначе будет бесконечный цикл). Аналогично в cnt == 1. После while учитываем случай, что наш подмассив заканчивается на последнем элементе",
    "code_snippet": "",
    "key_terms": ""
  },
  {
    "question": "Дана строка, состоящая из символов “X”, “O”, “Y”. Найти минимальное расстояние между “X” и “Y”. Если в строке отсутствует “X” или “Y”, вернуть 0. Примеры: “XY” → 1\n\n“XXX” → 0\n\n“YY” → 0\n\n“XOY” → 2\n\n“XOOYOXXXOY” → 2",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "",
    "code_snippet": "def func(s):\n\nif “X” not in s:\n\nreturn 0\n\nif “Y” not in s:\n\nreturn 0\n\nlast_x = -1\n\nlast_y = -1\n\nres = len(s)\n\nfor i in range(len(s)):\n\nif s[i] == “Y”:\n\nlast_y = i\n\nif s[i] == “X”:\n\nlast_x = i\n\nif last_x + last_y ≠ -2:\n\nres = min(res, abs(last_x - last_y))\n\n   return res",
    "key_terms": ""
  },
  {
    "question": "Есть два вектора, которые закодированы с помощью RLE. Надо посчитать их скалярное произведение",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "Делаем два указателя, шагаем по обоим массивам, делаем цикл while пока не дойдем до конца",
    "code_snippet": "",
    "key_terms": ""
  },
  {
    "question": "Есть дома, есть три вида краски - красная, зелёная, синяя. Каждый дом можно покрасить в определённый цвет за определённые деньги. Важная деталь - два соседних дома не могут быть одного цвета, например, не может быть последовательности “синий красный красный зелёный”. На вход подаётся N списков, где N равно числу домов, в каждом списке три числа - цена покраски в красный, зелёный, синий. Задача: Вывести минимальную стоимость покраски всех домов с учётом условие",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "Это динамика. По сути мы строим дерево и отсекаем ветки, в итоге получаем таблицу Nx3, на каждом шаге определяя минимум. решает за линию.",
    "code_snippet": "",
    "key_terms": ""
  },
  {
    "question": "Дан отсортированный целочисленный массив arr, два целых числа k и x, вернуть k ближайших целых чисел к x в массиве. Результат также должен быть отсортирован в порядке возрастания. Целое число a ближе к x, чем целое число b, если: |a - x| < |b - x|, or |a - x| == |b - x| and a < b Example 1:\n\nInput: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "",
    "code_snippet": "    def findClosestElements(self, A, k, x):\n        left, right = 0, len(A) - k\n        while left < right:\n            mid = (left + right) / 2\n            if x - A[mid] > A[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return A[left:left + k]",
    "key_terms": ""
  },
  {
    "question": "# Дан идентификатор ID банковской карты, содержащий произвольный набор символов вида 0123-4567-8901-2345 . # Требуется заменить все цифры символом '#', кроме 4-х последних. # Входные данные – идентификатор карты ID. # Выходные данные – требуемое представление. # Примеры: # 1234-5678-9012-3456 -> ####-####-####-3456 # 1234//4567 -> ####//4567 # 12-34-56-78 -> ##-##-56-78",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "",
    "code_snippet": "def securify(string: str) -> str: cnt = 0 arr = list(string) for i in range(len(string) - 1, -1, -1): x = string[i] if x.isdigit() == True: if cnt < 4: cnt += 1 else: arr[i] = '#' return ''.join(arr)",
    "key_terms": ""
  },
  {
    "question": "Дан массив точек с целочисленными координатами (x, y). Определить, существует ли вертикальная прямая, делящая точки на 2 симметричных относительно этой прямой множества. Note: Для удобства точку можно представлять не как массив [x, y], а как объект {x, y} \"\"\" # is_vert_sym([(0, 0), (0, 0), (1, 1), (2, 2), (3, 1), (4, 0), (4, 0)]) # True # is_vert_sym([(0, 0), (0, 0), (1, 1), (2, 2), (3, 1), (4, 0)]) # False # is_vert_sym([]) # True # is_vert_sym([(0, 0)]) # True # is_vert_sym([(0, 0), (10, 0)]) # True # is_vert_sym([(0, 0), (11, 1)]) # False # is_vert_sym([(0, 0), (1, 0), (3, 0)]) # False",
    "category": "Python",
    "question_type": "code",
    "difficulty": "Medium",
    "reference_answer": "",
    "code_snippet": "a + b = 2m\nb = 2m - a\n\ndef is_vert_sym(array: list) -> bool:\n    if len(array) == 0: \n        return True\n\n    points = dict()\n    for p in array:\n        if p in points:\n            points[p] += 1\n        else:\n            points[p] = 1\n\t\n    left, right = array[0][0], array[0][0]\n\n    for (x, y) in array:\n        if x < left:\n            left = x\n        elif x > right:\n            right = x\n\n    mid = (left + right) / 2\n\n    for (x, y) in array:\n        simm_x = int(2 * mid - x)\n        simm_p = (simm_x, y)\n        # points.get()\n        if x != mid and (simm_p not in points or points[(x, y)] != points[simm_p]):\n            return False\n\n    return True",
    "key_terms": ""
  }
]